"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeDictParser = exports.writeArgumentToStack = exports.writeTupleSerializer = exports.writeGetParser = exports.writeTupleParser = exports.writeInitSerializer = exports.writeSerializer = exports.writeParser = exports.writeStruct = void 0;
const serializers_1 = require("./serializers");
function writeStruct(name, fields, exp, w) {
    w.append(`${exp ? 'export ' : ' '}type ${name} = {`);
    w.inIndent(() => {
        w.append(`$$type: '${name}';`);
        outer: for (let f of fields) {
            for (let s of serializers_1.serializers) {
                let v = s.abiMatcher(f.type);
                if (v) {
                    w.append(`${f.name}: ${s.tsType(v)};`);
                    continue outer;
                }
            }
            throw Error('Unsupported type: ' + JSON.stringify(f.type));
        }
    });
    w.append(`}`);
    w.append();
}
exports.writeStruct = writeStruct;
function writeParser(s, allocation, w) {
    w.append(`export function load${s.name}(slice: Slice) {`);
    w.inIndent(() => {
        w.append(`let sc_0 = slice;`);
        if (s.header) {
            w.append(`if (sc_0.loadUint(32) !== ${s.header}) { throw Error('Invalid prefix'); }`);
        }
        writeParserCell(0, 0, allocation, s, w);
        w.append(`return { ${[`$$type: '${s.name}' as const`, ...s.fields.map((v) => v.name + ': _' + v.name)].join(', ')} };`);
    });
    w.append(`}`);
    w.append();
}
exports.writeParser = writeParser;
function writeParserCell(gen, offset, src, s, w) {
    for (let f of src.ops) {
        writeParserField(gen, offset++, s, w);
    }
    if (src.next) {
        w.append(`let sc_${gen + 1} = sc_${gen}.loadRef().beginParse();`);
        writeParserCell(gen + 1, offset, src.next, s, w);
    }
}
function writeParserField(gen, offset, s, w) {
    let name = '_' + s.fields[offset].name;
    let type = s.fields[offset].type;
    for (let s of serializers_1.serializers) {
        let v = s.abiMatcher(type);
        if (v) {
            s.tsLoad(v, `sc_${gen}`, name, w);
            return;
        }
    }
    throw Error('Unsupported type');
}
function writeSerializer(s, allocation, w) {
    w.append(`export function store${s.name}(src: ${s.name}) {`);
    w.inIndent(() => {
        w.append(`return (builder: Builder) => {`);
        w.inIndent(() => {
            w.append(`let b_0 = builder;`);
            if (s.header) {
                w.append(`b_0.storeUint(${s.header}, 32);`);
            }
            writeSerializerCell(0, allocation, w);
        });
        w.append(`};`);
    });
    w.append(`}`);
    w.append();
}
exports.writeSerializer = writeSerializer;
function writeInitSerializer(name, allocation, w) {
    w.append(`function init${name}(src: ${name}) {`);
    w.inIndent(() => {
        w.append(`return (builder: Builder) => {`);
        w.inIndent(() => {
            w.append(`let b_0 = builder;`);
            writeSerializerCell(0, allocation, w);
        });
        w.append(`};`);
    });
    w.append(`}`);
    w.append();
}
exports.writeInitSerializer = writeInitSerializer;
function writeSerializerCell(gen, src, w) {
    for (let f of src.ops) {
        writeSerializerField(gen, f, w);
    }
    if (src.next) {
        w.append(`let b_${gen + 1} = new Builder();`);
        writeSerializerCell(gen + 1, src.next, w);
        w.append(`b_${gen}.storeRef(b_${gen + 1}.endCell());`);
    }
}
function writeSerializerField(gen, s, w) {
    let name = 'src.' + s.name;
    let type = s.type;
    for (let s of serializers_1.serializers) {
        let v = s.abiMatcher(type);
        if (v) {
            s.tsStore(v, `b_${gen}`, name, w);
            return;
        }
    }
    throw Error('Unsupported field type: ' + JSON.stringify(type));
}
function writeTupleParser(s, w) {
    w.append(`function loadTuple${s.name}(source: TupleReader) {`);
    w.inIndent(() => {
        for (let f of s.fields) {
            writeTupleFieldParser('_' + f.name, f.type, w);
        }
        w.append(`return { ${[`$$type: '${s.name}' as const`, ...s.fields.map((v) => v.name + ': _' + v.name)].join(', ')} };`);
    });
    w.append(`}`);
    w.append();
}
exports.writeTupleParser = writeTupleParser;
function writeGetParser(name, type, w) {
    writeTupleFieldParser(name, type, w, true);
}
exports.writeGetParser = writeGetParser;
function writeTupleFieldParser(name, type, w, fromGet = false) {
    for (let s of serializers_1.serializers) {
        let v = s.abiMatcher(type);
        if (v) {
            s.tsLoadTuple(v, `source`, name, w, fromGet);
            return;
        }
    }
    throw Error('Unsupported field type: ' + JSON.stringify(type));
}
function writeTupleSerializer(s, w) {
    w.append(`function storeTuple${s.name}(source: ${s.name}) {`);
    w.inIndent(() => {
        w.append(`let builder = new TupleBuilder();`);
        for (let f of s.fields) {
            writeVariableToStack(`source.${f.name}`, f.type, w);
        }
        w.append(`return builder.build();`);
    });
    w.append(`}`);
    w.append();
}
exports.writeTupleSerializer = writeTupleSerializer;
function writeArgumentToStack(name, ref, w) {
    writeVariableToStack(name, ref, w);
}
exports.writeArgumentToStack = writeArgumentToStack;
function writeVariableToStack(name, type, w) {
    for (let s of serializers_1.serializers) {
        let v = s.abiMatcher(type);
        if (v) {
            s.tsStoreTuple(v, `builder`, name, w);
            return;
        }
    }
    throw Error('Unsupported field type: ' + JSON.stringify(type));
}
function writeDictParser(s, w) {
    w.write(`
        function dictValueParser${s.name}(): DictionaryValue<${s.name}> {
            return {
                serialize: (src, buidler) => {
                    buidler.storeRef(beginCell().store(store${s.name}(src)).endCell());
                },
                parse: (src) => {
                    return load${s.name}(src.loadRef().beginParse());
                }
            }
        }
    `);
    w.append();
}
exports.writeDictParser = writeDictParser;
