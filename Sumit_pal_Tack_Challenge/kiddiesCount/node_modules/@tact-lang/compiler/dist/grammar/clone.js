"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.cloneNode = void 0;
const ast_1 = require("./ast");
function cloneNode(src) {
    if (src.kind === 'boolean') {
        return (0, ast_1.cloneASTNode)(src);
    }
    else if (src.kind === 'id') {
        return (0, ast_1.cloneASTNode)(src);
    }
    else if (src.kind === 'null') {
        return (0, ast_1.cloneASTNode)(src);
    }
    else if (src.kind === 'number') {
        return (0, ast_1.cloneASTNode)(src);
    }
    else if (src.kind === 'string') {
        return (0, ast_1.cloneASTNode)(src);
    }
    else if (src.kind === 'lvalue_ref') {
        return (0, ast_1.cloneASTNode)(src);
    }
    else if (src.kind === 'statement_assign') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            path: src.path.map(cloneNode),
            expression: cloneNode(src.expression),
        });
    }
    else if (src.kind === 'statement_let') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            type: (0, ast_1.cloneASTNode)(src.type),
            expression: cloneNode(src.expression),
        });
    }
    else if (src.kind === 'statement_condition') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            expression: cloneNode(src.expression),
            trueStatements: src.trueStatements.map(cloneNode),
            falseStatements: src.falseStatements ? src.falseStatements.map(cloneNode) : null,
            elseif: src.elseif ? cloneNode(src.elseif) : null,
        });
    }
    else if (src.kind === 'new_parameter') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            exp: cloneNode(src.exp),
        });
    }
    else if (src.kind === 'statement_expression') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            expression: cloneNode(src.expression),
        });
    }
    else if (src.kind === 'op_binary') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            left: cloneNode(src.left),
            right: cloneNode(src.right),
        });
    }
    else if (src.kind === 'op_unary') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            right: cloneNode(src.right),
        });
    }
    else if (src.kind === 'op_new') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            args: src.args.map(cloneNode),
        });
    }
    else if (src.kind === 'op_call') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            src: cloneNode(src.src),
            args: src.args.map(cloneNode),
        });
    }
    else if (src.kind === 'op_field') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            src: cloneNode(src.src),
        });
    }
    else if (src.kind === 'op_static_call') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            args: src.args.map(cloneNode),
        });
    }
    else if (src.kind === 'statement_return') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            expression: src.expression ? cloneNode(src.expression) : null,
        });
    }
    else if (src.kind === 'statement_repeat') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            condition: cloneNode(src.condition),
            statements: src.statements.map(cloneNode),
        });
    }
    else if (src.kind === 'statement_until') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            condition: cloneNode(src.condition),
            statements: src.statements.map(cloneNode),
        });
    }
    else if (src.kind === 'statement_while') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            condition: cloneNode(src.condition),
            statements: src.statements.map(cloneNode),
        });
    }
    else if (src.kind === 'def_function') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            statements: src.statements ? src.statements.map(cloneNode) : null,
            args: src.args.map(cloneNode)
        });
    }
    else if (src.kind === 'def_native_function') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            args: src.args.map(cloneNode)
        });
    }
    else if (src.kind === 'def_receive') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            statements: src.statements.map(cloneNode),
        });
    }
    else if (src.kind === 'def_argument') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            type: (0, ast_1.cloneASTNode)(src.type),
        });
    }
    else if (src.kind === 'init_of') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            args: src.args.map(cloneNode),
        });
    }
    else if (src.kind === 'def_constant') {
        return (0, ast_1.cloneASTNode)({
            ...src,
            value: src.value ? cloneNode(src.value) : src.value,
        });
    }
    throw Error('Not implemented for ' + src.kind);
}
exports.cloneNode = cloneNode;
