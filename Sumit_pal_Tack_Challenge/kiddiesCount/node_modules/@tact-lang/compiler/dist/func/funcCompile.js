"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.funcCompile = exports.cutFirstLine = void 0;
const errorToString_1 = require("../utils/errorToString");
// Wasm Imports
const CompilerModule = require('./funcfiftlib.js');
const FuncFiftLibWasm = require('./funcfiftlib.wasm.js').FuncFiftLibWasm;
const WasmBinary = Buffer.from(FuncFiftLibWasm, 'base64');
const writeToCString = (mod, data) => {
    const len = mod.lengthBytesUTF8(data) + 1;
    const ptr = mod._malloc(len);
    mod.stringToUTF8(data, ptr, len);
    return ptr;
};
const writeToCStringPtr = (mod, str, ptr) => {
    const allocated = writeToCString(mod, str);
    mod.setValue(ptr, allocated, '*');
    return allocated;
};
const readFromCString = (mod, pointer) => mod.UTF8ToString(pointer);
function cutFirstLine(src) {
    return src.slice(src.indexOf('\n') + 1);
}
exports.cutFirstLine = cutFirstLine;
async function funcCompile(args) {
    // Parameters
    let files = args.entries;
    let configStr = JSON.stringify({
        sources: files,
        optLevel: 2 // compileConfig.optLevel || 2
    });
    // Pointer tracking
    const allocatedPointers = [];
    const allocatedFunctions = [];
    const trackPointer = (pointer) => {
        allocatedPointers.push(pointer);
        return pointer;
    };
    const trackFunctionPointer = (pointer) => {
        allocatedFunctions.push(pointer);
        return pointer;
    };
    // Create module
    let logs = [];
    let mod = await CompilerModule({ wasmBinary: WasmBinary, printErr: (e) => { logs.push(e); } });
    // Execute
    try {
        // Write config
        let configPointer = trackPointer(writeToCString(mod, configStr));
        // FS emulation callback
        const callbackPtr = trackFunctionPointer(mod.addFunction((_kind, _data, contents, error) => {
            const kind = readFromCString(mod, _kind);
            const data = readFromCString(mod, _data);
            if (kind === 'realpath') {
                allocatedPointers.push(writeToCStringPtr(mod, data, contents));
            }
            else if (kind === 'source') {
                try {
                    let fl = args.sources.find((v) => v.path === data);
                    if (!fl) {
                        throw Error('File not found: ' + data);
                    }
                    allocatedPointers.push(writeToCStringPtr(mod, fl.content, contents));
                }
                catch (err) {
                    const e = err;
                    allocatedPointers.push(writeToCStringPtr(mod, 'message' in e ? e.message : e.toString(), error));
                }
            }
            else {
                allocatedPointers.push(writeToCStringPtr(mod, 'Unknown callback kind ' + kind, error));
            }
        }, 'viiii'));
        // Execute
        let resultPointer = trackPointer(mod._func_compile(configPointer, callbackPtr));
        let retJson = readFromCString(mod, resultPointer);
        let result = JSON.parse(retJson);
        let msg = logs.join('\n');
        if (result.status === 'error') {
            return {
                ok: false,
                log: logs.length > 0 ? msg : (result.message ? result.message : 'Unknown error'),
                fift: null,
                output: null
            };
        }
        else if (result.status === 'ok') {
            return {
                ok: true,
                log: logs.length > 0 ? msg : (result.warnings ? result.warnings : ''),
                fift: cutFirstLine(result.fiftCode.replaceAll('\\n', '\n')),
                output: Buffer.from(result.codeBoc, 'base64')
            };
        }
        else {
            throw Error('Unexpected compiler response');
        }
    }
    catch (e) {
        args.logger.error((0, errorToString_1.errorToString)(e));
        throw Error('Unexpected compiler response');
    }
    finally {
        for (let i of allocatedFunctions) {
            mod.removeFunction(i);
        }
        for (let i of allocatedPointers) {
            mod._free(i);
        }
    }
}
exports.funcCompile = funcCompile;
