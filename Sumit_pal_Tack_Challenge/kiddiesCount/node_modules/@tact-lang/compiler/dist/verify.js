"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = void 0;
const path_normalize_1 = __importDefault(require("path-normalize"));
const ton_core_1 = require("ton-core");
const logger_1 = require("./logger");
const main_1 = require("./main");
const fileFormat_1 = require("./packaging/fileFormat");
const version_1 = require("./pipeline/version");
async function verify(args) {
    const logger = args.logger || logger_1.consoleLogger;
    // Loading package
    let unpacked;
    try {
        let data = JSON.parse(args.pkg);
        unpacked = fileFormat_1.fileFormat.parse(data);
    }
    catch (e) {
        return { ok: false, error: 'invalid-package-format' };
    }
    // Check compier and version
    if (unpacked.compiler.name !== 'tact') {
        return { ok: false, error: 'invalid-compiler' };
    }
    if (unpacked.compiler.version !== (0, version_1.getCompilerVersion)()) {
        return { ok: false, error: 'invalid-compiler-version' };
    }
    // Create a options
    if (!unpacked.compiler.parameters) {
        return { ok: false, error: 'invalid-package-format' };
    }
    let params = JSON.parse(unpacked.compiler.parameters);
    if (typeof params.entrypoint !== 'string') {
        return { ok: false, error: 'invalid-package-format' };
    }
    let options = params.options || {};
    let entrypoint = params.entrypoint;
    // Create config
    let config = {
        projects: [{
                name: 'verifier',
                path: (0, path_normalize_1.default)('./contract/' + entrypoint),
                output: './output',
                options
            }]
    };
    // Build
    let files = {};
    for (let s in unpacked.sources) {
        files['contract/' + s] = unpacked.sources[s];
    }
    let result = await (0, main_1.run)({ config, files, logger });
    if (!result) {
        return { ok: false, error: 'compilation-failed' };
    }
    // Read output
    let compiledCell = files['output/verifier_' + unpacked.name + '.code.boc'];
    if (!compiledCell) {
        return { ok: false, error: 'verification-failed' };
    }
    // Check output
    let a = ton_core_1.Cell.fromBase64(compiledCell);
    let b = ton_core_1.Cell.fromBase64(unpacked.code);
    if (!a.equals(b)) {
        return { ok: false, error: 'verification-failed' };
    }
    // Return
    return { ok: true, package: unpacked, files };
}
exports.verify = verify;
