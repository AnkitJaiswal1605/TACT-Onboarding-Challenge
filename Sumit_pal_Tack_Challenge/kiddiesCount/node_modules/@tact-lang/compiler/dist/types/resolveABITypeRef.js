"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createABITypeRefFromTypeRef = exports.resolveABIType = void 0;
const ast_1 = require("../grammar/ast");
const intFormats = {
    'int8': { type: 'int', format: 8 },
    'int16': { type: 'int', format: 16 },
    'int32': { type: 'int', format: 32 },
    'int64': { type: 'int', format: 64 },
    'int128': { type: 'int', format: 128 },
    'int256': { type: 'int', format: 256 },
    'uint8': { type: 'uint', format: 8 },
    'uint16': { type: 'uint', format: 16 },
    'uint32': { type: 'uint', format: 32 },
    'uint64': { type: 'uint', format: 64 },
    'uint128': { type: 'uint', format: 128 },
    'uint256': { type: 'uint', format: 256 },
    'int257': { type: 'int', format: 257 },
    'coins': { type: 'uint', format: 'coins' }
};
const intMapFormats = {
    'int8': { type: 'int', format: 8 },
    'int16': { type: 'int', format: 16 },
    'int32': { type: 'int', format: 32 },
    'int64': { type: 'int', format: 64 },
    'int128': { type: 'int', format: 128 },
    'int256': { type: 'int', format: 256 },
    'uint8': { type: 'uint', format: 8 },
    'uint16': { type: 'uint', format: 16 },
    'uint32': { type: 'uint', format: 32 },
    'uint64': { type: 'uint', format: 64 },
    'uint128': { type: 'uint', format: 128 },
    'uint256': { type: 'uint', format: 256 },
    'int257': { type: 'int', format: 257 }
};
const cellFormats = {
    'remaining': { type: 'cell', format: 'remainder' }
};
const sliceFormats = {
    'remaining': { type: 'slice', format: 'remainder' },
    'bytes32': { type: 'fixed-bytes', format: 32 },
    'bytes64': { type: 'fixed-bytes', format: 64 }
};
const builderFormats = {
    'remaining': { type: 'builder', format: 'remainder' }
};
function resolveABIType(src) {
    if (src.type.kind === 'type_ref_simple') {
        //
        // Primitive types
        //
        if (src.type.name === 'Int') {
            if (src.as) {
                let fmt = intFormats[src.as];
                if (!fmt) {
                    (0, ast_1.throwError)(`Unsupported format ${src.as}`, src.ref);
                }
                return { kind: 'simple', type: fmt.type, optional: src.type.optional, format: fmt.format };
            }
            return { kind: 'simple', type: 'int', optional: src.type.optional, format: 257 }; // Default is maximumx size int
        }
        if (src.type.name === 'Bool') {
            if (src.as) {
                (0, ast_1.throwError)(`Unsupported format ${src.as}`, src.ref);
            }
            return { kind: 'simple', type: 'bool', optional: src.type.optional };
        }
        if (src.type.name === 'Cell') {
            if (src.as) {
                let fmt = cellFormats[src.as];
                if (!fmt) {
                    (0, ast_1.throwError)(`Unsupported format ${src.as}`, src.ref);
                }
                return { kind: 'simple', type: fmt.type, optional: src.type.optional, format: fmt.format };
            }
            return { kind: 'simple', type: 'cell', optional: src.type.optional };
        }
        if (src.type.name === 'Slice') {
            if (src.as) {
                if (src.as) {
                    let fmt = sliceFormats[src.as];
                    if (!fmt) {
                        (0, ast_1.throwError)(`Unsupported format ${src.as}`, src.ref);
                    }
                    return { kind: 'simple', type: fmt.type, optional: src.type.optional, format: fmt.format };
                }
            }
            return { kind: 'simple', type: 'slice', optional: src.type.optional };
        }
        if (src.type.name === 'Builder') {
            if (src.as) {
                if (src.as) {
                    let fmt = builderFormats[src.as];
                    if (!fmt) {
                        (0, ast_1.throwError)(`Unsupported format ${src.as}`, src.ref);
                    }
                    return { kind: 'simple', type: fmt.type, optional: src.type.optional, format: fmt.format };
                }
            }
            return { kind: 'simple', type: 'builder', optional: src.type.optional };
        }
        if (src.type.name === 'Address') {
            if (src.as) {
                (0, ast_1.throwError)(`Unsupported format ${src.as}`, src.ref);
            }
            return { kind: 'simple', type: 'address', optional: src.type.optional };
        }
        if (src.type.name === 'String') {
            if (src.as) {
                (0, ast_1.throwError)(`Unsupported format ${src.as}`, src.ref);
            }
            return { kind: 'simple', type: 'string', optional: src.type.optional };
        }
        if (src.type.name === 'StringBuilder') {
            (0, ast_1.throwError)(`Unsupported type ${src.type.name}`, src.ref);
        }
        //
        // Structs
        //
        if (src.as) {
            if (src.as === 'reference') {
                return { kind: 'simple', type: src.type.name, optional: src.type.optional, format: 'ref' };
            }
            else {
                (0, ast_1.throwError)(`Unsupported format ${src.as}`, src.ref);
            }
        }
        return { kind: 'simple', type: src.type.name, optional: src.type.optional };
    }
    //
    // Map
    //
    if (src.type.kind === 'type_ref_map') {
        let key;
        let keyFormat = undefined;
        let value;
        let valueFormat = undefined;
        // Resolve key type
        if (src.type.key === 'Int') {
            key = 'int';
            if (src.type.keyAs) {
                let format = intMapFormats[src.type.keyAs];
                if (!format) {
                    (0, ast_1.throwError)(`Unsupported format ${src.type.keyAs} for map key`, src.ref);
                }
                key = format.type;
                keyFormat = format.format;
            }
        }
        else if (src.type.key === 'Address') {
            key = 'address';
            if (src.type.keyAs) {
                (0, ast_1.throwError)(`Unsupported format ${src.type.keyAs} for map key`, src.ref);
            }
        }
        else {
            (0, ast_1.throwError)(`Unsupported map key type ${src.type.key}`, src.ref);
        }
        // Resolve value type
        if (src.type.value === 'Int') {
            value = 'int';
            if (src.type.valueAs) {
                let format = intMapFormats[src.type.valueAs];
                if (!format) {
                    (0, ast_1.throwError)(`Unsupported format ${src.type.valueAs} for map value`, src.ref);
                }
                value = format.type;
                valueFormat = format.format;
            }
        }
        else if (src.type.value === 'Bool') {
            value = 'bool';
            if (src.type.valueAs) {
                (0, ast_1.throwError)(`Unsupported format ${src.type.valueAs} for map value`, src.ref);
            }
        }
        else if (src.type.value === 'Cell') {
            value = 'cell';
            valueFormat = 'ref';
            if (src.type.valueAs && src.type.valueAs !== 'reference') {
                (0, ast_1.throwError)(`Unsupported format ${src.type.valueAs} for map value`, src.ref);
            }
        }
        else if (src.type.value === 'Slice') {
            (0, ast_1.throwError)(`Unsupported map value type ${src.type.value}`, src.ref);
        }
        else if (src.type.value === 'Address') {
            value = 'address';
            if (src.type.valueAs) {
                (0, ast_1.throwError)(`Unsupported format ${src.type.valueAs} for map value`, src.ref);
            }
        }
        else if (src.type.value === 'String') {
            (0, ast_1.throwError)(`Unsupported map value type ${src.type.value}`, src.ref);
        }
        else if (src.type.value === 'StringBuilder' || src.type.value === 'Builder') {
            (0, ast_1.throwError)(`Unsupported map value type ${src.type.value}`, src.ref);
        }
        else {
            value = src.type.value;
            valueFormat = 'ref';
            if (src.type.valueAs && src.type.valueAs !== 'reference') {
                (0, ast_1.throwError)(`Unsupported format ${src.type.valueAs} for map value`, src.ref);
            }
        }
        return { kind: 'dict', key, keyFormat, value, valueFormat };
    }
    (0, ast_1.throwError)(`Unsupported type`, src.ref);
}
exports.resolveABIType = resolveABIType;
function createABITypeRefFromTypeRef(src, ref) {
    if (src.kind === 'ref') {
        // Primitives
        if (src.name === 'Int') {
            return { kind: 'simple', type: 'int', optional: src.optional, format: 257 }; // Default is maximumx size int
        }
        if (src.name === 'Bool') {
            return { kind: 'simple', type: 'bool', optional: src.optional };
        }
        if (src.name === 'Cell') {
            return { kind: 'simple', type: 'cell', optional: src.optional };
        }
        if (src.name === 'Slice') {
            return { kind: 'simple', type: 'slice', optional: src.optional };
        }
        if (src.name === 'Builder') {
            return { kind: 'simple', type: 'builder', optional: src.optional };
        }
        if (src.name === 'Address') {
            return { kind: 'simple', type: 'address', optional: src.optional };
        }
        if (src.name === 'String') {
            return { kind: 'simple', type: 'string', optional: src.optional };
        }
        if (src.name === 'StringBuilder') {
            throw Error(`Unsupported type ${src.name}`);
        }
        // Structs
        return { kind: 'simple', type: src.name, optional: src.optional };
    }
    if (src.kind === 'map') {
        let key;
        let keyFormat = undefined;
        let value;
        let valueFormat = undefined;
        // Resolve key type
        if (src.key === 'Int') {
            key = 'int';
            if (src.keyAs) {
                let format = intMapFormats[src.keyAs];
                if (!format) {
                    (0, ast_1.throwError)(`Unsupported format ${src.keyAs} for map key`, ref);
                }
                key = format.type;
                keyFormat = format.format;
            }
        }
        else if (src.key === 'Address') {
            key = 'address';
            if (src.keyAs) {
                (0, ast_1.throwError)(`Unsupported format ${src.keyAs} for map key`, ref);
            }
        }
        else {
            throw Error(`Unsupported map key type ${src.key}`);
        }
        // Resolve value type
        if (src.value === 'Int') {
            value = 'int';
            if (src.valueAs) {
                let format = intMapFormats[src.valueAs];
                if (!format) {
                    (0, ast_1.throwError)(`Unsupported format ${src.valueAs} for map value`, ref);
                }
                value = format.type;
                valueFormat = format.format;
            }
        }
        else if (src.value === 'Bool') {
            value = 'bool';
            if (src.valueAs) {
                (0, ast_1.throwError)(`Unsupported format ${src.valueAs} for map value`, ref);
            }
        }
        else if (src.value === 'Cell') {
            value = 'cell';
            valueFormat = 'ref';
            if (src.valueAs && src.valueAs !== 'reference') {
                (0, ast_1.throwError)(`Unsupported format ${src.valueAs} for map value`, ref);
            }
        }
        else if (src.value === 'Slice') {
            throw Error(`Unsupported map value type ${src.value}`);
        }
        else if (src.value === 'Address') {
            value = 'address';
            if (src.valueAs) {
                (0, ast_1.throwError)(`Unsupported format ${src.valueAs} for map value`, ref);
            }
        }
        else if (src.value === 'String') {
            throw Error(`Unsupported map value type ${src.value}`);
        }
        else if (src.value === 'StringBuilder' || src.value === 'Builder') {
            throw Error(`Unsupported map value type ${src.value}`);
        }
        else {
            value = src.value;
            valueFormat = 'ref';
            if (src.valueAs && src.valueAs !== 'reference') {
                (0, ast_1.throwError)(`Unsupported format ${src.valueAs} for map value`, ref);
            }
        }
        return { kind: 'dict', key, keyFormat, value, valueFormat };
    }
    if (src.kind === 'ref_bounced') {
        throw Error("Unexpected bounced reference");
    }
    throw Error(`Unsupported type`);
}
exports.createABITypeRefFromTypeRef = createABITypeRefFromTypeRef;
