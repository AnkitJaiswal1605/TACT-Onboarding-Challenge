"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createABI = void 0;
const errors_1 = require("../abi/errors");
const getSupportedInterfaces_1 = require("../types/getSupportedInterfaces");
const resolveABITypeRef_1 = require("../types/resolveABITypeRef");
const resolveDescriptors_1 = require("../types/resolveDescriptors");
const resolveErrors_1 = require("../types/resolveErrors");
function createABI(ctx, name) {
    let allTypes = Object.values((0, resolveDescriptors_1.getAllTypes)(ctx));
    // Contract
    let contract = allTypes.find((v) => v.name === name);
    if (!contract) {
        throw Error(`Contract ${name} not found`);
    }
    if (contract.kind !== 'contract') {
        throw Error('Not a contract');
    }
    // Structs
    let types = [];
    for (let t of allTypes) {
        if (t.kind === 'struct') {
            types.push({
                name: t.name,
                header: t.header,
                fields: t.fields.map((v) => v.abi)
            });
        }
    }
    // // Receivers
    let receivers = [];
    for (let r of Object.values(contract.receivers)) {
        if (r.selector.kind === 'internal-binary') {
            receivers.push({
                receiver: 'internal',
                message: {
                    kind: 'typed',
                    type: r.selector.type
                }
            });
        }
        else if (r.selector.kind === 'external-binary') {
            receivers.push({
                receiver: 'external',
                message: {
                    kind: 'typed',
                    type: r.selector.type
                }
            });
        }
        else if (r.selector.kind === 'internal-empty') {
            receivers.push({
                receiver: 'internal',
                message: {
                    kind: 'empty'
                }
            });
        }
        else if (r.selector.kind === 'external-empty') {
            receivers.push({
                receiver: 'external',
                message: {
                    kind: 'empty'
                }
            });
        }
        else if (r.selector.kind === 'internal-comment') {
            receivers.push({
                receiver: 'internal',
                message: {
                    kind: 'text',
                    text: r.selector.comment
                }
            });
        }
        else if (r.selector.kind === 'external-comment') {
            receivers.push({
                receiver: 'external',
                message: {
                    kind: 'text',
                    text: r.selector.comment
                }
            });
        }
        else if (r.selector.kind === 'internal-comment-fallback') {
            receivers.push({
                receiver: 'internal',
                message: {
                    kind: 'text'
                }
            });
        }
        else if (r.selector.kind === 'external-comment-fallback') {
            receivers.push({
                receiver: 'external',
                message: {
                    kind: 'text'
                }
            });
        }
        else if (r.selector.kind === 'internal-fallback') {
            receivers.push({
                receiver: 'internal',
                message: {
                    kind: 'any'
                }
            });
        }
        else if (r.selector.kind === 'external-fallback') {
            receivers.push({
                receiver: 'external',
                message: {
                    kind: 'any'
                }
            });
        }
    }
    // Getters
    let getters = [];
    for (let f of contract.functions.values()) {
        if (f.isGetter) {
            getters.push({
                name: f.name,
                arguments: f.args.map((v) => ({ name: v.name, type: (0, resolveABITypeRef_1.createABITypeRefFromTypeRef)(v.type, v.ref) })),
                returnType: f.returns.kind !== 'void' ? (0, resolveABITypeRef_1.createABITypeRefFromTypeRef)(f.returns, f.ast.ref) : null
            });
        }
    }
    // Errors
    let errors = {};
    errors['2'] = { message: 'Stack undeflow' };
    errors['3'] = { message: 'Stack overflow' };
    errors['4'] = { message: 'Integer overflow' };
    errors['5'] = { message: 'Integer out of expected range' };
    errors['6'] = { message: 'Invalid opcode' };
    errors['7'] = { message: 'Type check error' };
    errors['8'] = { message: 'Cell overflow' };
    errors['9'] = { message: 'Cell underflow' };
    errors['10'] = { message: 'Dictionary error' };
    errors['13'] = { message: 'Out of gas error' };
    errors['32'] = { message: 'Method ID not found' };
    errors['34'] = { message: 'Action is invalid or not supported' };
    errors['37'] = { message: 'Not enough TON' };
    errors['38'] = { message: 'Not enough extra-currencies' };
    for (let e of Object.values(errors_1.contractErrors)) {
        errors[e.id] = { message: e.message };
    }
    let codeErrors = (0, resolveErrors_1.getAllErrors)(ctx);
    for (let c of codeErrors) {
        errors[c.id + ''] = { message: c.value };
    }
    // Interfaces
    let interfaces = ['org.ton.introspection.v0', ...(0, getSupportedInterfaces_1.getSupportedIntefaces)(contract, ctx)];
    return {
        name: contract.name,
        types,
        receivers,
        getters,
        errors,
        interfaces
    };
}
exports.createABI = createABI;
