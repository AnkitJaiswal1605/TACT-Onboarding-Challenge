"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeGetter = exports.writeFunction = exports.writeStatement = exports.unwrapExternal = exports.writeCastedExpression = void 0;
const features_1 = require("../../config/features");
const resolveDescriptors_1 = require("../../types/resolveDescriptors");
const resolveExpression_1 = require("../../types/resolveExpression");
const utils_1 = require("../../utils/utils");
const resolveFuncPrimitive_1 = require("./resolveFuncPrimitive");
const resolveFuncType_1 = require("./resolveFuncType");
const resolveFuncTypeUnpack_1 = require("./resolveFuncTypeUnpack");
const id_1 = require("./id");
const writeExpression_1 = require("./writeExpression");
const cast_1 = require("./cast");
const resolveFuncTupledType_1 = require("./resolveFuncTupledType");
const ops_1 = require("./ops");
function writeCastedExpression(expression, to, ctx) {
    let expr = (0, resolveExpression_1.getExpType)(ctx.ctx, expression);
    return (0, cast_1.cast)(expr, to, (0, writeExpression_1.writeExpression)(expression, ctx), ctx); // Cast for nullable
}
exports.writeCastedExpression = writeCastedExpression;
function unwrapExternal(targetName, sourceName, type, ctx) {
    if (type.kind === 'ref') {
        let t = (0, resolveDescriptors_1.getType)(ctx.ctx, type.name);
        if (t.kind === 'struct') {
            if (type.optional) {
                ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = ${ops_1.ops.typeFromOptTuple(t.name, ctx)}(${sourceName});`);
            }
            else {
                ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = ${ops_1.ops.typeFromTuple(t.name, ctx)}(${sourceName});`);
            }
            return;
        }
        else if (t.kind === 'primitive' && t.name === 'Address') {
            if (type.optional) {
                ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = null?(${sourceName}) ? null() : ${ctx.used(`__tact_verify_address`)}(${sourceName});`);
            }
            else {
                ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = ${ctx.used(`__tact_verify_address`)}(${sourceName});`);
            }
            return;
        }
    }
    ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${targetName} = ${sourceName};`);
}
exports.unwrapExternal = unwrapExternal;
function writeStatement(f, self, returns, ctx) {
    if (f.kind === 'statement_return') {
        if (f.expression) {
            // Format expression
            let result = writeCastedExpression(f.expression, returns, ctx);
            // Return
            if (self) {
                ctx.append(`return (${self}, ${result});`);
            }
            else {
                ctx.append(`return ${result};`);
            }
        }
        else {
            if (self) {
                ctx.append(`return (${self}, ());`);
            }
            else {
                ctx.append(`return ();`);
            }
        }
        return;
    }
    else if (f.kind === 'statement_let') {
        // Contract/struct case
        let t = (0, resolveDescriptors_1.resolveTypeRef)(ctx.ctx, f.type);
        if (t.kind === 'ref') {
            let tt = (0, resolveDescriptors_1.getType)(ctx.ctx, t.name);
            if (tt.kind === 'contract' || tt.kind === 'struct') {
                if (t.optional) {
                    ctx.append(`tuple ${(0, id_1.id)(f.name)} = ${writeCastedExpression(f.expression, t, ctx)};`);
                }
                else {
                    ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, (0, id_1.id)(f.name), ctx)} = ${writeCastedExpression(f.expression, t, ctx)};`);
                }
                return;
            }
        }
        ctx.append(`${(0, resolveFuncType_1.resolveFuncType)(t, ctx)} ${(0, id_1.id)(f.name)} = ${writeCastedExpression(f.expression, t, ctx)};`);
        return;
    }
    else if (f.kind === 'statement_assign') {
        // Prepare lvalue
        let path = f.path.map((v, i) => (i === 0) ? (0, id_1.id)(v.name) : v.name).join(`'`);
        // Contract/struct case
        let t = (0, resolveExpression_1.getExpType)(ctx.ctx, f.path[f.path.length - 1]);
        if (t.kind === 'ref') {
            let tt = (0, resolveDescriptors_1.getType)(ctx.ctx, t.name);
            if (tt.kind === 'contract' || tt.kind === 'struct') {
                ctx.append(`${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, `${path}`, ctx)} = ${writeCastedExpression(f.expression, t, ctx)};`);
                return;
            }
        }
        ctx.append(`${path} = ${writeCastedExpression(f.expression, t, ctx)};`);
        return;
    }
    else if (f.kind === 'statement_condition') {
        writeCondition(f, self, false, returns, ctx);
        return;
    }
    else if (f.kind === 'statement_expression') {
        let exp = (0, writeExpression_1.writeExpression)(f.expression, ctx);
        ctx.append(`${exp};`);
        return;
    }
    else if (f.kind === 'statement_while') {
        ctx.append(`while (${(0, writeExpression_1.writeExpression)(f.condition, ctx)}) {`);
        ctx.inIndent(() => {
            for (let s of f.statements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`}`);
        return;
    }
    else if (f.kind === 'statement_until') {
        ctx.append(`do {`);
        ctx.inIndent(() => {
            for (let s of f.statements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`} until (${(0, writeExpression_1.writeExpression)(f.condition, ctx)});`);
        return;
    }
    else if (f.kind === 'statement_repeat') {
        ctx.append(`repeat (${(0, writeExpression_1.writeExpression)(f.condition, ctx)}) {`);
        ctx.inIndent(() => {
            for (let s of f.statements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`}`);
        return;
    }
    throw Error('Unknown statement kind');
}
exports.writeStatement = writeStatement;
function writeCondition(f, self, elseif, returns, ctx) {
    ctx.append(`${(elseif ? '} else' : '')}if (${(0, writeExpression_1.writeExpression)(f.expression, ctx)}) {`);
    ctx.inIndent(() => {
        for (let s of f.trueStatements) {
            writeStatement(s, self, returns, ctx);
        }
    });
    if (f.falseStatements && f.falseStatements.length > 0) {
        ctx.append(`} else {`);
        ctx.inIndent(() => {
            for (let s of f.falseStatements) {
                writeStatement(s, self, returns, ctx);
            }
        });
        ctx.append(`}`);
    }
    else if (f.elseif) {
        writeCondition(f.elseif, self, true, returns, ctx);
    }
    else {
        ctx.append(`}`);
    }
}
function writeFunction(f, ctx) {
    // Do not write native functions
    if (f.ast.kind === 'def_native_function') {
        return;
    }
    const fd = f.ast;
    // Resolve self
    let self = f.self ? (0, resolveDescriptors_1.getType)(ctx.ctx, f.self) : null;
    // Write function header
    let returns = (0, resolveFuncType_1.resolveFuncType)(f.returns, ctx);
    let returnsStr;
    if (self && f.isMutating) {
        if (f.returns.kind !== 'void') {
            returns = `(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}, ${returns})`;
        }
        else {
            returns = `(${(0, resolveFuncType_1.resolveFuncType)(self, ctx)}, ())`;
        }
        returnsStr = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx);
    }
    // Resolve function descriptor
    let name = self ? ops_1.ops.extension(self.name, f.name) : ops_1.ops.global(f.name);
    let args = [];
    if (self) {
        args.push((0, resolveFuncType_1.resolveFuncType)(self, ctx) + ' ' + (0, id_1.id)('self'));
    }
    for (let a of f.args) {
        args.push((0, resolveFuncType_1.resolveFuncType)(a.type, ctx) + ' ' + (0, id_1.id)(a.name));
    }
    // Write function body
    ctx.fun(name, () => {
        ctx.signature(`${returns} ${name}(${args.join(', ')})`);
        ctx.flag('impure');
        if ((0, features_1.enabledInline)(ctx.ctx) || f.isInline) {
            ctx.flag('inline');
        }
        if (f.origin === 'stdlib') {
            ctx.context('stdlib');
        }
        ctx.body(() => {
            // Unpack self
            if (self) {
                ctx.append(`var (${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx)}) = ${(0, id_1.id)('self')};`);
            }
            for (let a of fd.args) {
                if (!(0, resolveFuncPrimitive_1.resolveFuncPrimitive)((0, resolveDescriptors_1.resolveTypeRef)(ctx.ctx, a.type), ctx)) {
                    ctx.append(`var (${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)((0, resolveDescriptors_1.resolveTypeRef)(ctx.ctx, a.type), (0, id_1.id)(a.name), ctx)}) = ${(0, id_1.id)(a.name)};`);
                }
            }
            // Process statements
            for (let s of fd.statements) {
                writeStatement(s, returnsStr, f.returns, ctx);
            }
            // Auto append return
            if (f.self && (f.returns.kind === 'void') && f.isMutating) {
                if (fd.statements.length === 0 || fd.statements[fd.statements.length - 1].kind !== 'statement_return') {
                    ctx.append(`return (${returnsStr}, ());`);
                }
            }
        });
    });
}
exports.writeFunction = writeFunction;
function writeGetter(f, ctx) {
    // Render tensors
    const self = f.self ? (0, resolveDescriptors_1.getType)(ctx.ctx, f.self) : null;
    if (!self) {
        throw new Error(`No self type for getter ${f.name}`); // Impossible
    }
    ctx.append(`_ %${f.name}(${f.args.map((v) => (0, resolveFuncTupledType_1.resolveFuncTupledType)(v.type, ctx) + ' ' + (0, id_1.id)('$' + v.name)).join(', ')}) method_id(${(0, utils_1.getMethodId)(f.name)}) {`);
    ctx.inIndent(() => {
        // Unpack arguments
        for (let arg of f.args) {
            unwrapExternal((0, id_1.id)(arg.name), (0, id_1.id)('$' + arg.name), arg.type, ctx);
        }
        // Load contract state
        ctx.append(`var self = ${ops_1.ops.contractLoad(self.name, ctx)}();`);
        // Execute get method
        ctx.append(`var res = self~${ctx.used(ops_1.ops.extension(self.name, f.name))}(${f.args.map((v) => (0, id_1.id)(v.name)).join(', ')});`);
        // Pack if needed
        if (f.returns.kind === 'ref') {
            let t = (0, resolveDescriptors_1.getType)(ctx.ctx, f.returns.name);
            if (t.kind === 'struct') {
                if (f.returns.optional) {
                    ctx.append(`return ${ops_1.ops.typeToOptExternal(t.name, ctx)}(res);`);
                }
                else {
                    ctx.append(`return ${ops_1.ops.typeToExternal(t.name, ctx)}(res);`);
                }
                return;
            }
        }
        // Return restult
        ctx.append(`return res;`);
    });
    ctx.append(`}`);
    ctx.append();
}
exports.writeGetter = writeGetter;
