"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveImports = void 0;
const grammar_1 = require("../grammar/grammar");
const resolveLibrary_1 = require("./resolveLibrary");
function resolveImports(args) {
    //
    // Load stdlib and entrypoint
    //
    // const stdlibFuncPath = args.stdlib.resolve('./stdlib.fc');
    // const stdlibFunc = args.stdlib.readFile(stdlibFuncPath).toString();
    const stdlibTactPath = args.stdlib.resolve('stdlib.tact');
    const stdlibTact = args.stdlib.readFile(stdlibTactPath).toString();
    const codePath = args.project.resolve(args.entrypoint);
    const code = args.project.readFile(codePath).toString();
    //
    // Resolve all imports
    //
    const importedTact = [];
    const importedFunc = [];
    const processed = new Set();
    const pending = [];
    function processImports(source, path, origin) {
        const imp = (0, grammar_1.parseImports)(source, path, origin);
        for (const i of imp) {
            // Resolve library
            const resolved = (0, resolveLibrary_1.resolveLibrary)({
                path: path,
                name: i,
                project: args.project,
                stdlib: args.stdlib
            });
            if (!resolved.ok) {
                throw new Error(`Could not resolve import ${i} in ${path}`);
            }
            // Check if already imported
            if (resolved.kind === 'func') {
                if (importedFunc.find((v) => v.path === resolved.path)) {
                    continue;
                }
            }
            else {
                if (importedTact.find((v) => v.path === resolved.path)) {
                    continue;
                }
            }
            // Load code
            let vfs = resolved.source === 'project' ? args.project : args.stdlib;
            let code = vfs.readFile(resolved.path).toString();
            // Add to imports
            if (resolved.kind === 'func') {
                importedFunc.push({ code, path: resolved.path, origin });
            }
            else {
                if (!processed.has(resolved.path)) {
                    processed.add(resolved.path);
                    pending.push({ path: resolved.path, code, origin });
                }
            }
        }
    }
    // Run resolve
    importedTact.push({ code: stdlibTact, path: stdlibTactPath, origin: 'stdlib' });
    processImports(stdlibTact, stdlibTactPath, 'stdlib');
    processImports(code, codePath, 'user');
    while (pending.length > 0) {
        let p = pending.shift();
        importedTact.push(p);
        processImports(p.code, p.path, p.origin);
    }
    importedTact.push({ code: code, path: codePath, origin: 'user' }); // To keep order same as before refactoring
    // Assemble result
    return {
        tact: [
            ...importedTact,
        ],
        func: [
            // { code: stdlibFunc, path: stdlibFuncPath },
            ...importedFunc
        ]
    };
}
exports.resolveImports = resolveImports;
