"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RemoteBlockchainStorage = exports.wrapTonClient4ForRemote = exports.LocalBlockchainStorage = void 0;
const ton_core_1 = require("ton-core");
const SmartContract_1 = require("./SmartContract");
class LocalBlockchainStorage {
    constructor() {
        this.contracts = new Map();
    }
    async getContract(blockchain, address) {
        let existing = this.contracts.get(address.toString());
        if (!existing) {
            existing = SmartContract_1.SmartContract.empty(blockchain, address);
            this.contracts.set(address.toString(), existing);
        }
        return existing;
    }
    knownContracts() {
        return Array.from(this.contracts.values());
    }
    clearKnownContracts() {
        this.contracts.clear();
    }
}
exports.LocalBlockchainStorage = LocalBlockchainStorage;
function convertTonClient4State(state) {
    switch (state.type) {
        case 'uninit':
            return { type: 'uninit' };
        case 'active':
            return { type: 'active', state: { code: state.code === null ? undefined : ton_core_1.Cell.fromBase64(state.code), data: state.data === null ? undefined : ton_core_1.Cell.fromBase64(state.data) } };
        case 'frozen':
            return { type: 'frozen', stateHash: BigInt('0x' + Buffer.from(state.stateHash, 'base64').toString('hex')) };
        default:
            throw new Error(`Unknown type ${state}`);
    }
}
function wrapTonClient4ForRemote(client) {
    return {
        getLastBlockSeqno: async () => {
            const last = await client.getLastBlock();
            return last.last.seqno;
        },
        getAccount: async (seqno, address) => {
            const { account } = await client.getAccount(seqno, address);
            return {
                state: convertTonClient4State(account.state),
                balance: BigInt(account.balance.coins),
                lastTransaction: account.last === null ? undefined : {
                    lt: BigInt(account.last.lt),
                    hash: Buffer.from(account.last.hash, 'base64'),
                },
            };
        },
    };
}
exports.wrapTonClient4ForRemote = wrapTonClient4ForRemote;
class RemoteBlockchainStorage {
    constructor(client, blockSeqno) {
        this.contracts = new Map();
        this.client = client;
        this.blockSeqno = blockSeqno;
    }
    async getLastBlockSeqno() {
        return this.blockSeqno ?? await this.client.getLastBlockSeqno();
    }
    async getContract(blockchain, address) {
        let existing = this.contracts.get(address.toString());
        if (!existing) {
            let blockSeqno = await this.getLastBlockSeqno();
            let account = await this.client.getAccount(blockSeqno, address);
            const lt = account.lastTransaction?.lt ?? 0n;
            existing = new SmartContract_1.SmartContract({
                lastTransactionHash: BigInt('0x' + (account.lastTransaction?.hash?.toString('hex') ?? '0')),
                lastTransactionLt: lt,
                account: {
                    addr: address,
                    storageStats: {
                        used: {
                            cells: 0n,
                            bits: 0n,
                            publicCells: 0n,
                        },
                        lastPaid: 0,
                        duePayment: null,
                    },
                    storage: {
                        lastTransLt: lt === 0n ? 0n : (lt + 1n),
                        balance: { coins: account.balance },
                        state: account.state,
                    },
                },
            }, blockchain);
            this.contracts.set(address.toString(), existing);
        }
        return existing;
    }
    knownContracts() {
        return Array.from(this.contracts.values());
    }
    clearKnownContracts() {
        this.contracts.clear();
    }
}
exports.RemoteBlockchainStorage = RemoteBlockchainStorage;
