"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Executor = void 0;
const ton_core_1 = require("ton-core");
const base64_1 = require("../utils/base64");
const EmulatorModule = require('./emulator-emscripten.js');
const verbosityToNum = {
    'short': 0,
    'full': 1,
    'full_location': 2,
    'full_location_gas': 3,
    'full_location_stack': 4,
    'full_location_stack_verbose': 5,
};
function runCommonArgsToInternalParams(args) {
    return {
        utime: args.now,
        lt: args.lt.toString(),
        rand_seed: args.randomSeed === null ? '' : args.randomSeed.toString('hex'),
        ignore_chksig: args.ignoreChksig,
        debug_enabled: args.debugEnabled,
    };
}
class Pointer {
    constructor(length, rawPointer) {
        this.inUse = true;
        this.length = length;
        this.rawPointer = rawPointer;
    }
    alloc() {
        this.inUse = true;
    }
    free() {
        this.inUse = false;
    }
}
class Heap {
    constructor(module) {
        this.pointers = [];
        this.maxPtrs = 0;
        this.module = module;
    }
    getPointersForStrings(strs) {
        this.maxPtrs = Math.max(this.maxPtrs, strs.length);
        const sorted = strs.map((str, i) => ({ str, i })).sort((a, b) => b.str.length - a.str.length);
        const ptrs = sorted.map(e => ({ i: e.i, ptr: this.getCStringPointer(e.str) })).sort((a, b) => a.i - b.i).map(e => e.ptr.rawPointer);
        this.pointers.sort((a, b) => b.length - a.length);
        this.pointers.slice(this.maxPtrs).forEach(ptr => this.module._free(ptr.rawPointer));
        this.pointers = this.pointers.slice(0, this.maxPtrs);
        this.pointers.forEach(p => p.free());
        return ptrs;
    }
    getCStringPointer(data) {
        let length = this.module.lengthBytesUTF8(data) + 1;
        let existing = this.pointers.find(p => p.length >= length && !p.inUse);
        if (existing) {
            this.module.stringToUTF8(data, existing.rawPointer, length);
            existing.alloc();
            return existing;
        }
        const len = this.module.lengthBytesUTF8(data) + 1;
        const ptr = this.module._malloc(len);
        this.module.stringToUTF8(data, ptr, len);
        let pointer = new Pointer(length, ptr);
        this.pointers.push(new Pointer(length, ptr));
        return pointer;
    }
}
class Executor {
    constructor(module) {
        this.debugLogs = [];
        this.module = module;
        this.heap = new Heap(module);
    }
    static async create() {
        const ex = new Executor(await EmulatorModule({
            wasmBinary: (0, base64_1.base64Decode)(require('./emulator-emscripten.wasm.js').EmulatorEmscriptenWasm),
            printErr: (text) => ex.debugLogs.push(text),
        }));
        return ex;
    }
    runGetMethod(args) {
        const params = {
            code: args.code.toBoc().toString('base64'),
            data: args.data.toBoc().toString('base64'),
            verbosity: verbosityToNum[args.verbosity],
            libs: args.libs?.toBoc().toString('base64') ?? '',
            address: args.address.toString(),
            unixtime: args.unixTime,
            balance: args.balance.toString(),
            rand_seed: args.randomSeed.toString('hex'),
            gas_limit: args.gasLimit.toString(),
            method_id: args.methodId,
            debug_enabled: args.debugEnabled,
        };
        let stack = (0, ton_core_1.serializeTuple)(args.stack);
        this.debugLogs = [];
        const resp = JSON.parse(this.extractString(this.invoke('_run_get_method', [
            JSON.stringify(params),
            stack.toBoc().toString('base64'),
            args.config,
        ])));
        const debugLogs = this.debugLogs.join('\n');
        if (resp.fail) {
            console.error(resp);
            throw new Error('Unknown emulation error');
        }
        return {
            output: resp.output,
            logs: resp.logs,
            debugLogs,
        };
    }
    runCommon(args) {
        this.debugLogs = [];
        const resp = JSON.parse(this.extractString(this.invoke('_emulate', args)));
        const debugLogs = this.debugLogs.join('\n');
        if (resp.fail) {
            console.error(resp);
            throw new Error('Unknown emulation error');
        }
        const logs = resp.logs;
        const result = resp.output;
        return {
            result: result.success ? {
                success: true,
                transaction: result.transaction,
                shardAccount: result.shard_account,
                vmLog: result.vm_log,
                actions: result.actions,
            } : {
                success: false,
                error: result.error,
                vmResults: 'vm_log' in result ? {
                    vmLog: result.vm_log,
                    vmExitCode: result.vm_exit_code,
                } : undefined,
            },
            logs,
            debugLogs,
        };
    }
    runTickTock(args) {
        const params = {
            ...runCommonArgsToInternalParams(args),
            is_tick_tock: true,
            is_tock: args.which === 'tock',
        };
        return this.runCommon([
            this.getEmulatorPointer(args.config, verbosityToNum[args.verbosity]),
            args.libs?.toBoc().toString('base64') ?? 0,
            args.shardAccount,
            '',
            JSON.stringify(params),
        ]);
    }
    runTransaction(args) {
        const params = runCommonArgsToInternalParams(args);
        return this.runCommon([
            this.getEmulatorPointer(args.config, verbosityToNum[args.verbosity]),
            args.libs?.toBoc().toString('base64') ?? 0,
            args.shardAccount,
            args.message.toBoc().toString('base64'),
            JSON.stringify(params),
        ]);
    }
    createEmulator(config, verbosity) {
        if (this.emulator !== undefined) {
            this.invoke('_destroy_emulator', [this.emulator.ptr]);
        }
        const ptr = this.invoke('_create_emulator', [config, verbosity]);
        this.emulator = {
            ptr,
            config,
            verbosity,
        };
    }
    getEmulatorPointer(config, verbosity) {
        if (this.emulator === undefined || verbosity !== this.emulator.verbosity || config !== this.emulator.config) {
            this.createEmulator(config, verbosity);
        }
        return this.emulator.ptr;
    }
    invoke(method, args) {
        const invocationArgs = [];
        const strArgs = [];
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (typeof arg === 'string') {
                strArgs.push({ str: arg, i });
            }
            else {
                invocationArgs[i] = arg;
            }
        }
        const strPtrs = this.heap.getPointersForStrings(strArgs.map(e => e.str));
        for (let i = 0; i < strPtrs.length; i++) {
            invocationArgs[strArgs[i].i] = strPtrs[i];
        }
        return this.module[method](...invocationArgs);
    }
    extractString(ptr) {
        const str = this.module.UTF8ToString(ptr);
        this.module._free(ptr);
        return str;
    }
}
exports.Executor = Executor;
