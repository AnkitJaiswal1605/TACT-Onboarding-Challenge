"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitStringReader = void 0;
const bn_js_1 = require("bn.js");
const __1 = require("..");
class BitStringReader {
    constructor(string) {
        this.offset = 0;
        let r = Buffer.alloc(string.buffer.length);
        string.buffer.copy(r);
        this.buffer = r;
        this.length = string.cursor;
    }
    get currentOffset() {
        return this.offset;
    }
    get remaining() {
        return this.length - this.offset;
    }
    skip(bits) {
        for (let i = 0; i < bits; i++) {
            this.readBit();
        }
    }
    readUint(bits) {
        if (bits == 0) {
            return new bn_js_1.BN(0);
        }
        let res = '';
        for (let i = 0; i < bits; i++) {
            res += this.readBit() ? '1' : '0';
        }
        return new bn_js_1.BN(res, 2);
    }
    readUintNumber(bits) {
        return this.readUint(bits).toNumber();
    }
    readInt(bits) {
        if (bits === 0) {
            return new bn_js_1.BN(0);
        }
        if (bits === 1) {
            if (this.readBit() /* isNegative */) {
                return new bn_js_1.BN(-1);
            }
            else {
                return new bn_js_1.BN(0);
            }
        }
        if (this.readBit() /* isNegative */) {
            let base = this.readUint(bits - 1);
            const b = new bn_js_1.BN(2);
            const nb = b.pow(new bn_js_1.BN(bits - 1));
            return base.sub(nb);
        }
        else {
            return this.readUint(bits - 1);
        }
    }
    readIntNumber(bits) {
        return this.readInt(bits).toNumber();
    }
    readBuffer(size) {
        let res = [];
        for (let i = 0; i < size; i++) {
            res.push(this.readUintNumber(8));
        }
        return Buffer.from(res);
    }
    readBit() {
        let r = this.getBit(this.offset);
        this.offset++;
        return r;
    }
    readCoins() {
        let bytes = this.readUintNumber(4);
        if (bytes === 0) {
            return new bn_js_1.BN(0);
        }
        return new bn_js_1.BN(this.readBuffer(bytes).toString('hex'), 'hex');
    }
    readVarUInt(headerBits) {
        let bytes = this.readUintNumber(headerBits);
        if (bytes === 0) {
            return new bn_js_1.BN(0);
        }
        return new bn_js_1.BN(this.readBuffer(bytes).toString('hex'), 'hex');
    }
    readVarUIntNumber(headerBits) {
        return this.readVarUInt(headerBits).toNumber();
    }
    readUnaryLength() {
        let res = 0;
        while (this.readBit()) {
            res++;
        }
        return res;
    }
    readRemaining() {
        let res = __1.BitString.alloc(1023);
        while (this.offset < this.length) {
            res.writeBit(this.readBit());
        }
        return res;
    }
    readAddress() {
        let type = this.readUintNumber(2);
        if (type === 0) {
            return null;
        }
        if (type !== 2) {
            throw Error('Only STD address supported');
        }
        if (this.readUintNumber(1) !== 0) {
            throw Error('Only STD address supported');
        }
        const wc = this.readIntNumber(8);
        const hash = this.readBuffer(32);
        return new __1.Address(wc, hash);
    }
    getBit(n) {
        if (n >= this.length || n < 0) {
            throw Error('Out of range');
        }
        return (this.buffer[(n / 8) | 0] & (1 << (7 - (n % 8)))) > 0;
    }
}
exports.BitStringReader = BitStringReader;
