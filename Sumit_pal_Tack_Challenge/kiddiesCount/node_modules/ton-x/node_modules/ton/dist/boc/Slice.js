"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Slice = void 0;
const __1 = require("..");
class Slice {
    constructor(sourceBits, sourceRefs) {
        this.refs = [];
        this.skip = (bits) => {
            this.bits.skip(bits);
        };
        this.readUint = (bits) => {
            return this.bits.readUint(bits);
        };
        this.readUintNumber = (bits) => {
            return this.bits.readUintNumber(bits);
        };
        this.readInt = (bits) => {
            return this.bits.readInt(bits);
        };
        this.readIntNumber = (bits) => {
            return this.bits.readIntNumber(bits);
        };
        this.readBuffer = (size) => {
            return this.bits.readBuffer(size);
        };
        this.readBit = () => {
            return this.bits.readBit();
        };
        this.readCoins = () => {
            return this.bits.readCoins();
        };
        this.readVarUInt = (headerBits) => {
            return this.bits.readVarUInt(headerBits);
        };
        this.readVarUIntNumber = (headerBits) => {
            return this.bits.readVarUIntNumber(headerBits);
        };
        this.readRemaining = () => {
            return this.bits.readRemaining();
        };
        this.readRemainingBytes = () => {
            if (this.bits.remaining % 8 !== 0) {
                throw Error('Number remaining of bits is not multiply of 8');
            }
            return this.bits.readBuffer(this.bits.remaining / 8);
        };
        this.readAddress = () => {
            return this.bits.readAddress();
        };
        this.readUnaryLength = () => {
            return this.bits.readUnaryLength();
        };
        this.readOptDict = (keySize, extractor) => {
            if (this.readBit()) {
                return this.readDict(keySize, extractor);
            }
            else {
                return null;
            }
        };
        this.readDict = (keySize, extractor) => {
            let first = this.refs.shift();
            if (first) {
                return (0, __1.parseDict)(first.beginParse(), keySize, extractor);
            }
            else {
                throw Error('No ref');
            }
        };
        this.readRef = () => {
            let first = this.refs.shift();
            if (first) {
                return Slice.fromCell(first);
            }
            else {
                throw Error('No ref');
            }
        };
        this.readCell = () => {
            let first = this.refs.shift();
            if (first) {
                return first;
            }
            else {
                throw Error('No ref');
            }
        };
        this.clone = () => {
            // Copy remaining
            const cloned = this.sourceBits.clone();
            const reader = new __1.BitStringReader(cloned);
            reader.skip(this.bits.currentOffset);
            const remaining = reader.readRemaining();
            const remainingRefs = [...this.refs];
            // Build slice
            return new Slice(remaining, remainingRefs);
        };
        this.toCell = () => {
            // Copy remaining
            const cloned = this.sourceBits.clone();
            const reader = new __1.BitStringReader(cloned);
            reader.skip(this.bits.currentOffset);
            const remaining = reader.readRemaining();
            let cell = new __1.Cell(false, remaining);
            for (let r of this.refs) {
                cell.refs.push(r);
            }
            return cell;
        };
        this.sourceBits = sourceBits.clone();
        this.refs = [...sourceRefs];
        this.bits = new __1.BitStringReader(this.sourceBits);
    }
    static fromCell(cell) {
        return new Slice(cell.bits, cell.refs);
    }
    get remaining() {
        return this.bits.remaining;
    }
    get remainingRefs() {
        return this.refs.length;
    }
}
exports.Slice = Slice;
