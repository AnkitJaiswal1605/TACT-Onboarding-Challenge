/// <reference types="bn.js" />
/// <reference types="node" />
import { Address } from "../address/Address";
import { Message } from "../messages/Message";
import { Cell } from "../boc/Cell";
import { Contract } from "../contracts/Contract";
import { Wallet } from "./Wallet";
import { Maybe } from '../types';
import { WalletContractType, WalletSource } from '..';
import { TonTransaction } from './TonTransaction';
import { ConfigContract } from '../contracts/ConfigContract';
import { TonCache } from './TonCache';
import { AxiosAdapter } from 'axios';
export declare type TonClientParameters = {
    endpoint: string;
    cache?: Maybe<TonCache>;
    /**
     * HTTP request timeout in milliseconds.
     */
    timeout?: number;
    /**
     * API Key
     */
    apiKey?: string;
    /**
     * HTTP Adapter for axios
     */
    httpAdapter?: AxiosAdapter;
};
export declare type TonClientResolvedParameters = {
    endpoint: string;
    cache: TonCache;
};
export declare class TonClient {
    #private;
    readonly parameters: TonClientResolvedParameters;
    services: {
        configs: ConfigContract;
    };
    constructor(parameters: TonClientParameters);
    /**
     * Get Address Balance
     * @param address address for balance check
     * @returns balance
     */
    getBalance(address: Address): Promise<import("bn.js")>;
    /**
     * Invoke get method
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
     */
    callGetMethod(address: Address, name: string, params?: any[]): Promise<{
        gas_used: number;
        stack: any[];
    }>;
    /**
     * Invoke get method that returns error code instead of throwing error
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
    */
    callGetMethodWithError(address: Address, name: string, params?: any[]): Promise<{
        gas_used: number;
        stack: any[];
        exit_code: number;
    }>;
    /**
     * Get transactions
     * @param address address
     */
    getTransactions(address: Address, opts: {
        limit: number;
        lt?: string;
        hash?: string;
        to_lt?: string;
        inclusive?: boolean;
    }): Promise<TonTransaction[]>;
    /**
     * Get transaction by it's id
     * @param address address
     * @param lt logical time
     * @param hash transaction hash
     * @returns transaction or null if not exist
     */
    getTransaction(address: Address, lt: string, hash: string): Promise<TonTransaction | null>;
    /**
     * Fetch latest masterchain info
     * @returns masterchain info
     */
    getMasterchainInfo(): Promise<{
        workchain: number;
        shard: string;
        initSeqno: number;
        latestSeqno: number;
    }>;
    /**
     * Fetch latest workchain shards
     * @param seqno masterchain seqno
     */
    getWorkchainShards(seqno: number): Promise<{
        workchain: number;
        shard: string;
        seqno: number;
    }[]>;
    /**
     * Fetch transactions inf shards
     * @param workchain
     * @param seqno
     * @param shard
     */
    getShardTransactions(workchain: number, seqno: number, shard: string): Promise<{
        account: Address;
        lt: string;
        hash: string;
    }[]>;
    /**
     * Send message to a network
     * @param src source message
     */
    sendMessage(src: Message): Promise<void>;
    /**
     * Send file to a network
     * @param src source file
     */
    sendFile(src: Buffer): Promise<void>;
    /**
     * Estimate fees for external message
     * @param address target address
     * @returns
     */
    estimateExternalMessageFee(address: Address, args: {
        body: Cell;
        initCode: Cell | null;
        initData: Cell | null;
        ignoreSignature: boolean;
    }): Promise<{
        '@type': "query.fees";
        source_fees: {
            '@type': "fees";
            in_fwd_fee: number;
            storage_fee: number;
            gas_fee: number;
            fwd_fee: number;
        };
    }>;
    /**
     * Send external message to contract
     * @param contract contract to send message
     * @param src message body
     */
    sendExternalMessage(contract: Contract, src: Cell): Promise<void>;
    /**
     * Check if contract is deployed
     * @param address addres to check
     * @returns true if contract is in active state
     */
    isContractDeployed(address: Address): Promise<boolean>;
    /**
     * Resolves contract state
     * @param address contract address
     */
    getContractState(address: Address): Promise<{
        balance: import("bn.js");
        state: "active" | "uninitialized" | "frozen";
        code: Buffer | null;
        data: Buffer | null;
        lastTransaction: {
            lt: string;
            hash: string;
        } | null;
        blockId: {
            workchain: number;
            shard: string;
            seqno: number;
        };
        timestampt: number;
    }>;
    /**
     * Open Wallet from address
     * @param source wallet address
     * @returns wallet with specified address
     */
    openWalletFromAddress(args: {
        source: Address;
    }): Wallet;
    /**
     * Open Wallet from secret key. Searches for best wallet contract.
     * @param workchain wallet workchain
     * @param secretKey wallet secret key
     * @returns best matched wallet
     */
    findWalletFromSecretKey(args: {
        workchain: number;
        secretKey: Buffer;
    }): Promise<Wallet>;
    /**
     * Open wallet with default contract
     * @param args workchain and secret key
     * @returns wallet
     */
    openWalletDefaultFromSecretKey(args: {
        workchain: number;
        secretKey: Buffer;
    }): Wallet;
    /**
     * Open wallet with default contract
     * @param args workchain and secret key
     * @returns wallet
     */
    openWalletFromSecretKey(args: {
        workchain: number;
        secretKey: Buffer;
        type: WalletContractType;
    }): Wallet;
    /**
     * Opens wallet from custom contract
     * @param src source
     * @returns wallet
     */
    openWalletFromCustomContract(src: WalletSource): Wallet;
    /**
     * Securely creates new wallet
     * @param password optional password
     */
    createNewWallet(args: {
        workchain: number;
        password?: Maybe<string>;
        type?: Maybe<WalletContractType>;
    }): Promise<{
        mnemonic: string[];
        key: import("ton-crypto").KeyPair;
        wallet: Wallet;
    }>;
}
