"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveSignatures = void 0;
const changeCase = __importStar(require("change-case"));
const idToHex_1 = require("../utils/idToHex");
const newMessageId_1 = require("../utils/newMessageId");
const resolveDescriptors_1 = require("./resolveDescriptors");
function resolveSignatures(ctx) {
    let types = (0, resolveDescriptors_1.getAllTypes)(ctx);
    let signatures = new Map();
    function createTypeFormat(type, format) {
        if (type === 'int') {
            if (typeof format === 'number') {
                return `int${format}`;
            }
            else if (format !== null) {
                throw Error('Unsupported int format ' + format);
            }
            return `int`;
        }
        else if (type === 'uint') {
            if (typeof format === 'number') {
                return `uint${format}`;
            }
            else if (format === 'coins') {
                return `coins`;
            }
            else if (format !== null) {
                throw Error('Unsupported uint format ' + format);
            }
            return `uint`;
        }
        else if (type === 'bool') {
            if (format !== null) {
                throw Error('Unsupported bool format ' + format);
            }
            return 'bool';
        }
        else if (type === 'address') {
            if (format !== null) {
                throw Error('Unsupported address format ' + format);
            }
            return 'address';
        }
        else if (type === 'cell') {
            if (format === 'remainder') {
                return 'remainder<cell>';
            }
            else if (format === 'ref') {
                return '^cell';
            }
            if (format !== null) {
                throw Error('Unsupported cell format ' + format);
            }
            return '^cell';
        }
        else if (type === 'slice') {
            if (format === 'remainder') {
                return 'remainder<slice>';
            }
            else if (format === 'ref') {
                return '^slice';
            }
            else if (format !== null) {
                throw Error('Unsupported slice format ' + format);
            }
            return '^slice';
        }
        else if (type === 'builder') {
            if (format === 'remainder') {
                return 'remainder<builder>';
            }
            else if (format === 'ref') {
                return '^slice';
            }
            else if (format !== null) {
                throw Error('Unsupported builder format ' + format);
            }
            return '^builder';
        }
        else if (type === 'string') {
            if (format !== null) {
                throw Error('Unsupported builder format ' + format);
            }
            return '^string';
        }
        else if (type === 'fixed-bytes') {
            if (typeof format === 'number') {
                return `fixed_bytes${format}`;
            }
            else if (format !== null) {
                throw Error('Unsupported fixed-bytes format ' + format);
            }
            throw Error('Missing fixed-bytes format');
        }
        // Struct types
        let t = (0, resolveDescriptors_1.getType)(ctx, type);
        if (t.kind !== 'struct') {
            throw Error('Unsupported type ' + type);
        }
        let s = createTupeSignature(type);
        if (format === 'ref') {
            return `^${s.signature}`;
        }
        else if (format !== null) {
            throw Error('Unsupported struct format ' + format);
        }
        return `${s.signature}`;
    }
    function createTLBField(src) {
        if (src.type.kind === 'simple') {
            let base = createTypeFormat(src.type.type, src.type.format ? src.type.format : null);
            if (src.type.optional) {
                base = 'Maybe ' + base;
            }
            return src.name + ':' + base;
        }
        if (src.type.kind === 'dict') {
            if (src.type.format !== null && src.type.format !== undefined) {
                throw Error('Unsupported map format ' + src.type.format);
            }
            let key = createTypeFormat(src.type.key, src.type.keyFormat ? src.type.keyFormat : null);
            let value = createTypeFormat(src.type.value, src.type.valueFormat ? src.type.valueFormat : null);
            return src.name + ':dict<' + key + ', ' + value + '>';
        }
        throw Error('Unsupported ABI field');
    }
    function createTupeSignature(name) {
        if (signatures.has(name)) {
            return signatures.get(name);
        }
        let t = (0, resolveDescriptors_1.getType)(ctx, name);
        if (t.kind !== 'struct') {
            throw Error('Unsupported type ' + name);
        }
        let fields = t.fields.map((v) => createTLBField(v.abi));
        // Calculate signature and method id
        let signature = name + '{' + fields.join(',') + '}';
        let id = null;
        if (t.ast.kind === 'def_struct' && t.ast.message) {
            if (t.ast.prefix !== null) {
                id = t.ast.prefix;
            }
            else {
                id = (0, newMessageId_1.newMessageId)(signature);
            }
        }
        // Calculate TLB
        let tlbHeader = (id !== null ? changeCase.snakeCase(name) + '#' + (0, idToHex_1.idToHex)(id) : '_');
        let tlb = tlbHeader + ' ' + fields.join(' ') + ' = ' + name;
        signatures.set(name, { signature, id, tlb });
        return { signature, id, tlb };
    }
    for (let k in types) {
        let t = types[k];
        if (t.kind === 'struct') {
            let r = createTupeSignature(t.name);
            t.tlb = r.tlb;
            t.signature = r.signature;
            t.header = r.id;
        }
    }
    return ctx;
}
exports.resolveSignatures = resolveSignatures;
