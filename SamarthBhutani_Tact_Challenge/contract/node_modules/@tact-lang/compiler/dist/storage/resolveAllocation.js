"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveAllocations = exports.getSortedTypes = exports.getAllocations = exports.getAllocation = void 0;
const context_1 = require("../context");
const resolveDescriptors_1 = require("../types/resolveDescriptors");
const utils_1 = require("../utils/utils");
const allocator_1 = require("./allocator");
const resolveABITypeRef_1 = require("../types/resolveABITypeRef");
const id_1 = require("../generator/writers/id");
let store = (0, context_1.createContextStore)();
function getAllocation(ctx, name) {
    let t = store.get(ctx, name);
    if (!t) {
        throw Error('Allocation for ' + name + ' not found');
    }
    return t;
}
exports.getAllocation = getAllocation;
function getAllocations(ctx) {
    return getSortedTypes(ctx).map((v) => ({ allocation: getAllocation(ctx, v.name), type: v }));
}
exports.getAllocations = getAllocations;
function getSortedTypes(ctx) {
    let types = Object.values((0, resolveDescriptors_1.getAllTypes)(ctx)).filter((v) => v.kind === 'struct' || v.kind === 'contract');
    let structs = types.filter(t => t.kind === 'struct');
    let refs = (src) => {
        let res = [];
        let t = new Set();
        for (let f of src.fields) {
            let r = f.type;
            if (r.kind === 'ref') {
                let tp = (0, resolveDescriptors_1.getType)(ctx, r.name);
                if (tp.kind === 'struct') {
                    if (!t.has(tp.name)) {
                        t.add(r.name);
                        res.push(tp);
                    }
                }
            }
        }
        return res;
    };
    structs = (0, utils_1.topologicalSort)(structs, refs);
    structs = [...structs, ...types.filter((v) => v.kind === 'contract')];
    return structs;
}
exports.getSortedTypes = getSortedTypes;
function resolveAllocations(ctx) {
    // Load topological order of structs and contracts
    let types = getSortedTypes(ctx);
    // Generate allocations
    for (let s of types) {
        // Reserve bits
        let reserveBits = 0;
        let header = null;
        if (s.header !== null) {
            reserveBits += 32; // Header size
            header = { value: s.header, bits: 32 };
        }
        // Reserver refs
        let reserveRefs = 0;
        if (s.kind === 'contract') {
            reserveRefs += 1; // Internal state
        }
        // Convert fields
        let ops = [];
        let partialOps = [];
        for (let [i, f] of s.fields.entries()) {
            const op = {
                name: f.name,
                type: f.abi.type,
                op: (0, allocator_1.getAllocationOperationFromField)(f.abi.type, (name) => getAllocation(ctx, name).size)
            };
            ops.push(op);
            if (i < s.partialFieldCount) {
                partialOps.push(op);
            }
        }
        // Perform allocation
        let root = (0, allocator_1.allocate)({ ops, reserved: { bits: reserveBits, refs: reserveRefs } });
        let partialRoot = (0, allocator_1.allocate)({ ops: partialOps, reserved: { bits: reserveBits, refs: reserveRefs } });
        // Store allocation
        let allocation = {
            ops,
            root,
            header,
            size: {
                bits: root.size.bits + reserveBits,
                refs: root.size.refs + reserveRefs
            }
        };
        let partialAllocation = {
            ops: partialOps,
            root: partialRoot,
            header,
            size: {
                bits: root.size.bits + reserveBits,
                refs: root.size.refs + reserveRefs
            }
        };
        ctx = store.set(ctx, s.name, allocation);
        ctx = store.set(ctx, (0, resolveDescriptors_1.toBounced)(s.name), partialAllocation);
    }
    // Generate init allocations
    for (let s of types) {
        if (s.kind === 'contract' && s.init) {
            // Reserve bits and refs
            let reserveBits = 0;
            let reserveRefs = 0;
            // Reserve first bit for init state
            reserveBits++;
            // Reserve ref for system cell
            reserveRefs++;
            // Resolve opts
            let ops = [];
            for (let f of s.init.args) {
                let abiType = (0, resolveABITypeRef_1.createABITypeRefFromTypeRef)(f.type, f.ref);
                ops.push({
                    name: f.name,
                    type: abiType,
                    op: (0, allocator_1.getAllocationOperationFromField)(abiType, (name) => getAllocation(ctx, name).size)
                });
            }
            // Perform allocation
            let root = (0, allocator_1.allocate)({ ops, reserved: { bits: reserveBits, refs: reserveRefs } }); // Better allocation?
            // Store allocation
            let allocation = {
                ops,
                root,
                header: null,
                size: {
                    bits: root.size.bits + reserveBits,
                    refs: root.size.refs + reserveRefs
                }
            };
            ctx = store.set(ctx, (0, id_1.initId)(s.name), allocation);
        }
    }
    return ctx;
}
exports.resolveAllocations = resolveAllocations;
