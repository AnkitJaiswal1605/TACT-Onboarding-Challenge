"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverse = exports.throwError = exports.createRef = exports.inFile = exports.__DANGER_resetNodeId = exports.cloneASTNode = exports.createNode = exports.ASTRef = void 0;
const errors_1 = require("../errors");
class ASTRef {
    static merge(...refs) {
        if (refs.length === 0) {
            throw Error('Cannot merge 0 refs');
        }
        let r = refs[0].#interval;
        let file = refs[0].#file;
        for (let i = 1; i < refs.length; i++) {
            r = r.coverageWith(r, refs[i].#interval);
        }
        return new ASTRef(r, file);
    }
    #interval;
    #file;
    constructor(interval, file) {
        this.#interval = interval;
        this.#file = file;
    }
    get file() {
        return this.#file;
    }
    get contents() {
        return this.#interval.contents;
    }
    get interval() {
        return this.#interval;
    }
}
exports.ASTRef = ASTRef;
let nextId = 1;
function createNode(src) {
    return Object.freeze(Object.assign({ id: nextId++ }, src));
}
exports.createNode = createNode;
function cloneASTNode(src) {
    return { ...src, id: nextId++ };
}
exports.cloneASTNode = cloneASTNode;
function __DANGER_resetNodeId() {
    nextId = 1;
}
exports.__DANGER_resetNodeId = __DANGER_resetNodeId;
let currentFile = null;
function inFile(path, callback) {
    currentFile = path;
    let r = callback();
    currentFile = null;
    return r;
}
exports.inFile = inFile;
function createRef(s, ...extra) {
    let i = s.source;
    if (extra.length > 0) {
        i = i.coverageWith(...extra.map((e) => e.source));
    }
    return new ASTRef(i, currentFile);
}
exports.createRef = createRef;
function throwError(message, ref) {
    if (ref.file) {
        let lc = ref.interval.getLineAndColumn();
        throw new errors_1.TactSyntaxError(ref.file + ':' + lc.lineNum + ':' + lc.colNum + ': ' + message + '\n' + ref.interval.getLineAndColumnMessage(), ref);
    }
    else {
        throw new errors_1.TactSyntaxError(message + ref.interval.getLineAndColumnMessage(), ref);
    }
}
exports.throwError = throwError;
function traverse(node, callback) {
    callback(node);
    //
    // Program
    //
    if (node.kind === 'program') {
        for (let e of node.entries) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'def_contract') {
        for (let e of node.declarations) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'def_struct') {
        for (let e of node.fields) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'def_trait') {
        for (let e of node.declarations) {
            traverse(e, callback);
        }
    }
    //
    // Functions
    //
    if (node.kind === 'def_function') {
        for (let e of node.args) {
            traverse(e, callback);
        }
        if (node.statements) {
            for (let e of node.statements) {
                traverse(e, callback);
            }
        }
    }
    if (node.kind === 'def_init_function') {
        for (let e of node.args) {
            traverse(e, callback);
        }
        for (let e of node.statements) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'def_receive') {
        for (let e of node.statements) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'def_native_function') {
        for (let e of node.args) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'def_field') {
        if (node.init) {
            traverse(node.init, callback);
        }
    }
    if (node.kind === 'def_constant') {
        if (node.value) {
            traverse(node.value, callback);
        }
    }
    //
    // Statements
    //
    if (node.kind === 'statement_let') {
        traverse(node.type, callback);
        traverse(node.expression, callback);
    }
    if (node.kind === 'statement_return') {
        if (node.expression) {
            traverse(node.expression, callback);
        }
    }
    if (node.kind === 'statement_expression') {
        traverse(node.expression, callback);
    }
    if (node.kind === 'statement_assign') {
        for (let e of node.path) {
            traverse(e, callback);
        }
        traverse(node.expression, callback);
    }
    if (node.kind === 'statement_condition') {
        traverse(node.expression, callback);
        for (let e of node.trueStatements) {
            traverse(e, callback);
        }
        if (node.falseStatements) {
            for (let e of node.falseStatements) {
                traverse(e, callback);
            }
        }
        if (node.elseif) {
            traverse(node.elseif, callback);
        }
    }
    if (node.kind === 'statement_while') {
        traverse(node.condition, callback);
        for (let e of node.statements) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'statement_until') {
        traverse(node.condition, callback);
        for (let e of node.statements) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'statement_repeat') {
        traverse(node.condition, callback);
        for (let e of node.statements) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'op_binary') {
        traverse(node.left, callback);
        traverse(node.right, callback);
    }
    if (node.kind === 'op_unary') {
        traverse(node.right, callback);
    }
    if (node.kind === 'op_field') {
        traverse(node.src, callback);
    }
    if (node.kind === 'op_call') {
        traverse(node.src, callback);
        for (let e of node.args) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'op_static_call') {
        for (let e of node.args) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'op_new') {
        for (let e of node.args) {
            traverse(e, callback);
        }
    }
    if (node.kind === 'new_parameter') {
        traverse(node.exp, callback);
    }
}
exports.traverse = traverse;
