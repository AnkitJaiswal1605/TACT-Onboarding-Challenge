"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeAccessors = void 0;
const errors_1 = require("../../abi/errors");
const resolveDescriptors_1 = require("../../types/resolveDescriptors");
const ops_1 = require("./ops");
const resolveFuncFlatPack_1 = require("./resolveFuncFlatPack");
const resolveFuncFlatTypes_1 = require("./resolveFuncFlatTypes");
const resolveFuncTupledType_1 = require("./resolveFuncTupledType");
const resolveFuncType_1 = require("./resolveFuncType");
const resolveFuncTypeUnpack_1 = require("./resolveFuncTypeUnpack");
function writeAccessors(type, origin, ctx) {
    // Getters
    for (let f of type.fields) {
        ctx.fun(ops_1.ops.typeField(type.name, f.name, ctx), () => {
            ctx.signature(`_ ${ops_1.ops.typeField(type.name, f.name, ctx)}(${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} v)`);
            ctx.flag('inline');
            ctx.context('type:' + type.name);
            ctx.body(() => {
                ctx.append(`var (${type.fields.map((v) => `v'${v.name}`).join(', ')}) = v;`);
                ctx.append(`return v'${f.name};`);
            });
        });
    }
    // Tensor cast
    ctx.fun(ops_1.ops.typeTensorCast(type.name, ctx), () => {
        ctx.signature(`(${(0, resolveFuncType_1.resolveFuncType)(type, ctx)}) ${ops_1.ops.typeTensorCast(type.name, ctx)}(${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} v)`);
        ctx.context('type:' + type.name);
        ctx.asm('asm "NOP"');
    });
    // Not null
    ctx.fun(ops_1.ops.typeNotNull(type.name, ctx), () => {
        ctx.signature(`(${(0, resolveFuncType_1.resolveFuncType)(type, ctx)}) ${ops_1.ops.typeNotNull(type.name, ctx)}(tuple v)`);
        ctx.flag('inline');
        ctx.context('type:' + type.name);
        ctx.body(() => {
            ctx.append(`throw_if(${errors_1.contractErrors.null.id}, null?(v));`);
            let flatPack = (0, resolveFuncFlatPack_1.resolveFuncFlatPack)(type, 'vvv', ctx);
            let flatTypes = (0, resolveFuncFlatTypes_1.resolveFuncFlatTypes)(type, ctx);
            if (flatPack.length !== flatTypes.length)
                throw Error('Flat pack and flat types length mismatch');
            let pairs = flatPack.map((v, i) => `${flatTypes[i]} ${v}`);
            ctx.used(`__tact_tuple_destroy_${flatPack.length}`);
            ctx.append(`var (${pairs.join(', ')}) = __tact_tuple_destroy_${flatPack.length}(v);`);
            ctx.append(`return ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(type, 'vvv', ctx)};`);
        });
    });
    // As optional
    ctx.fun(ops_1.ops.typeAsOptional(type.name, ctx), () => {
        ctx.signature(`tuple ${ops_1.ops.typeAsOptional(type.name, ctx)}(${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} v)`);
        ctx.flag('inline');
        ctx.context('type:' + type.name);
        ctx.body(() => {
            ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(type, 'v', ctx)} = v;`);
            let flatPack = (0, resolveFuncFlatPack_1.resolveFuncFlatPack)(type, 'v', ctx);
            ctx.used(`__tact_tuple_create_${flatPack.length}`);
            ctx.append(`return __tact_tuple_create_${flatPack.length}(${flatPack.join(', ')});`);
        });
    });
    //
    // Convert to and from tupled representation
    //
    ctx.fun(ops_1.ops.typeToTuple(type.name, ctx), () => {
        ctx.signature(`tuple ${ops_1.ops.typeToTuple(type.name, ctx)}((${(0, resolveFuncType_1.resolveFuncType)(type, ctx)}) v)`);
        ctx.flag('inline');
        ctx.context('type:' + type.name);
        ctx.body(() => {
            ctx.append(`var (${type.fields.map((v) => `v'${v.name}`).join(', ')}) = v;`);
            let vars = [];
            for (let f of type.fields) {
                if (f.type.kind === 'ref') {
                    let t = (0, resolveDescriptors_1.getType)(ctx.ctx, f.type.name);
                    if (t.kind === 'struct') {
                        if (f.type.optional) {
                            vars.push(`${ops_1.ops.typeToOptTuple(f.type.name, ctx)}(v'${f.name})`);
                        }
                        else {
                            vars.push(`${ops_1.ops.typeToTuple(f.type.name, ctx)}(v'${f.name})`);
                        }
                        continue;
                    }
                }
                vars.push(`v'${f.name}`);
            }
            ctx.used(`__tact_tuple_create_${vars.length}`);
            ctx.append(`return __tact_tuple_create_${vars.length}(${vars.join(', ')});`);
        });
    });
    ctx.fun(ops_1.ops.typeToOptTuple(type.name, ctx), () => {
        ctx.signature(`tuple ${ops_1.ops.typeToOptTuple(type.name, ctx)}(tuple v)`);
        ctx.flag('inline');
        ctx.context('type:' + type.name);
        ctx.body(() => {
            ctx.append(`if (null?(v)) { return null(); } `);
            ctx.append(`return ${ops_1.ops.typeToTuple(type.name, ctx)}(${ops_1.ops.typeNotNull(type.name, ctx)}(v)); `);
        });
    });
    ctx.fun(ops_1.ops.typeFromTuple(type.name, ctx), () => {
        ctx.signature(`(${type.fields.map((v) => (0, resolveFuncType_1.resolveFuncType)(v.type, ctx)).join(', ')}) ${ops_1.ops.typeFromTuple(type.name, ctx)}(tuple v)`);
        ctx.flag('inline');
        ctx.context('type:' + type.name);
        ctx.body(() => {
            // Resolve vars
            let vars = [];
            let out = [];
            for (let f of type.fields) {
                if (f.type.kind === 'ref') {
                    let t = (0, resolveDescriptors_1.getType)(ctx.ctx, f.type.name);
                    if (t.kind === 'struct') {
                        vars.push(`tuple v'${f.name}`);
                        if (f.type.optional) {
                            out.push(`${ops_1.ops.typeFromOptTuple(f.type.name, ctx)}(v'${f.name})`);
                        }
                        else {
                            out.push(`${ops_1.ops.typeFromTuple(f.type.name, ctx)}(v'${f.name})`);
                        }
                        continue;
                    }
                    else if (t.kind === 'primitive' && t.name === 'Address') {
                        if (f.type.optional) {
                            vars.push(`${(0, resolveFuncType_1.resolveFuncType)(f.type, ctx)} v'${f.name}`);
                            out.push(`null?(v'${f.name}) ? null() : ${ctx.used(`__tact_verify_address`)}(v'${f.name})`);
                        }
                        else {
                            vars.push(`${(0, resolveFuncType_1.resolveFuncType)(f.type, ctx)} v'${f.name}`);
                            out.push(`${ctx.used(`__tact_verify_address`)}(v'${f.name})`);
                        }
                        continue;
                    }
                }
                vars.push(`${(0, resolveFuncType_1.resolveFuncType)(f.type, ctx)} v'${f.name}`);
                out.push(`v'${f.name}`);
            }
            ctx.used(`__tact_tuple_destroy_${vars.length}`);
            ctx.append(`var (${vars.join(', ')}) = __tact_tuple_destroy_${vars.length}(v);`);
            ctx.append(`return (${out.join(', ')});`);
        });
    });
    ctx.fun(ops_1.ops.typeFromOptTuple(type.name, ctx), () => {
        ctx.signature(`tuple ${ops_1.ops.typeFromOptTuple(type.name, ctx)}(tuple v)`);
        ctx.flag('inline');
        ctx.context('type:' + type.name);
        ctx.body(() => {
            ctx.append(`if (null?(v)) { return null(); } `);
            ctx.append(`return ${ops_1.ops.typeAsOptional(type.name, ctx)}(${ops_1.ops.typeFromTuple(type.name, ctx)}(v));`);
        });
    });
    //
    // Convert to and from external representation
    //
    ctx.fun(ops_1.ops.typeToExternal(type.name, ctx), () => {
        ctx.signature(`(${type.fields.map((v) => (0, resolveFuncTupledType_1.resolveFuncTupledType)(v.type, ctx)).join(', ')}) ${ops_1.ops.typeToExternal(type.name, ctx)}((${(0, resolveFuncType_1.resolveFuncType)(type, ctx)}) v)`);
        ctx.flag('inline');
        ctx.context('type:' + type.name);
        ctx.body(() => {
            ctx.append(`var (${type.fields.map((v) => `v'${v.name}`).join(', ')}) = v; `);
            let vars = [];
            for (let f of type.fields) {
                if (f.type.kind === 'ref') {
                    let t = (0, resolveDescriptors_1.getType)(ctx.ctx, f.type.name);
                    if (t.kind === 'struct') {
                        if (f.type.optional) {
                            vars.push(`${ops_1.ops.typeToOptTuple(f.type.name, ctx)}(v'${f.name})`);
                        }
                        else {
                            vars.push(`${ops_1.ops.typeToTuple(f.type.name, ctx)}(v'${f.name})`);
                        }
                        continue;
                    }
                }
                vars.push(`v'${f.name}`);
            }
            ctx.append(`return (${vars.join(', ')});`);
        });
    });
    ctx.fun(ops_1.ops.typeToOptExternal(type.name, ctx), () => {
        ctx.signature(`tuple ${ops_1.ops.typeToOptExternal(type.name, ctx)}(tuple v)`);
        ctx.flag('inline');
        ctx.context('type:' + type.name);
        ctx.body(() => {
            ctx.append(`var loaded = ${ops_1.ops.typeToOptTuple(type.name, ctx)}(v);`);
            ctx.append(`if (null?(loaded)) {`);
            ctx.inIndent(() => {
                ctx.append(`return null();`);
            });
            ctx.append(`} else {`);
            ctx.inIndent(() => {
                ctx.append(`return (loaded);`);
            });
            ctx.append(`}`);
        });
    });
}
exports.writeAccessors = writeAccessors;
