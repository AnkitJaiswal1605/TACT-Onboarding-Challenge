"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeReceiver = exports.writeRouter = void 0;
const ton_core_1 = require("ton-core");
const resolveDescriptors_1 = require("../../types/resolveDescriptors");
const id_1 = require("./id");
const ops_1 = require("./ops");
const resolveFuncType_1 = require("./resolveFuncType");
const resolveFuncTypeUnpack_1 = require("./resolveFuncTypeUnpack");
const writeFunction_1 = require("./writeFunction");
function writeRouter(type, kind, ctx) {
    const internal = kind === 'internal';
    if (internal) {
        ctx.append(`(${(0, resolveFuncType_1.resolveFuncType)(type, ctx)}, int) ${ops_1.ops.contractRouter(type.name, kind)}(${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} self, int msg_bounced, slice in_msg) impure inline_ref {`);
    }
    else {
        ctx.append(`(${(0, resolveFuncType_1.resolveFuncType)(type, ctx)}, int) ${ops_1.ops.contractRouter(type.name, kind)}(${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} self, slice in_msg) impure inline_ref {`);
    }
    ctx.inIndent(() => {
        // Handle bounced
        if (internal) {
            ctx.append(`;; Handle bounced messages`);
            ctx.append(`if (msg_bounced) {`);
            ctx.inIndent(() => {
                const bounceReceivers = type.receivers.filter(r => {
                    return r.selector.kind === "bounce-binary";
                });
                const fallbackReceiver = type.receivers.find(r => {
                    return r.selector.kind === "bounce-fallback";
                });
                if (fallbackReceiver || bounceReceivers.length > 0) {
                    ctx.append();
                    ctx.append(`;; Skip 0xFFFFFFFF`);
                    ctx.append(`in_msg~skip_bits(32);`);
                    ctx.append();
                }
                if (bounceReceivers.length > 0) {
                    ctx.append(`;; Parse op`);
                    ctx.append(`int op = 0;`);
                    ctx.append(`if (slice_bits(in_msg) >= 32) {`);
                    ctx.inIndent(() => {
                        ctx.append(`op = in_msg.preload_uint(32);`);
                    });
                    ctx.append(`}`);
                    ctx.append();
                }
                for (const r of bounceReceivers) {
                    const selector = r.selector;
                    if (selector.kind !== "bounce-binary")
                        throw Error('Invalid selector type: ' + selector.kind); // Should not happen
                    let allocation = (0, resolveDescriptors_1.getType)(ctx.ctx, selector.type);
                    if (!allocation)
                        throw Error('Invalid allocation: ' + selector.type); // Should not happen
                    ctx.append(`;; Bounced handler for ${selector.type} message`);
                    ctx.append(`if (op == ${allocation.header}) {`);
                    ctx.inIndent(() => {
                        // Read message
                        ctx.append(`var msg = in_msg~${selector.bounced ? ops_1.ops.readerBounced(selector.type, ctx) : ops_1.ops.reader(selector.type, ctx)}();`);
                        // Execute function
                        ctx.append(`self~${ops_1.ops.receiveTypeBounce(type.name, selector.type)}(msg);`);
                        // Exit
                        ctx.append('return (self, true);');
                    });
                    ctx.append(`}`);
                    ctx.append();
                }
                if (fallbackReceiver) {
                    const selector = fallbackReceiver.selector;
                    if (selector.kind !== "bounce-fallback")
                        throw Error('Invalid selector type: ' + selector.kind);
                    // Execute function
                    ctx.append(`;; Fallback bounce receiver`);
                    ctx.append(`self~${ops_1.ops.receiveBounceAny(type.name)}(in_msg);`);
                    ctx.append();
                    // Exit
                    ctx.append('return (self, true);');
                }
                else {
                    ctx.append(`return (self, true);`);
                }
            });
            ctx.append(`}`);
        }
        // Parse incoming message
        ctx.append();
        ctx.append(`;; Parse incoming message`);
        ctx.append(`int op = 0;`);
        ctx.append(`if (slice_bits(in_msg) >= 32) {`);
        ctx.inIndent(() => {
            ctx.append(`op = in_msg.preload_uint(32);`);
        });
        ctx.append(`}`);
        ctx.append();
        // Non-empty receivers
        for (const f of type.receivers) {
            const selector = f.selector;
            // Generic receiver
            if (selector.kind === (internal ? 'internal-binary' : 'external-binary')) {
                let allocation = (0, resolveDescriptors_1.getType)(ctx.ctx, selector.type);
                if (!allocation.header) {
                    throw Error('Invalid allocation: ' + selector.type);
                }
                ctx.append();
                ctx.append(`;; Receive ${selector.type} message`);
                ctx.append(`if (op == ${allocation.header}) {`);
                ctx.inIndent(() => {
                    // Read message
                    ctx.append(`var msg = in_msg~${ops_1.ops.reader(selector.type, ctx)}();`);
                    // Execute function
                    ctx.append(`self~${ops_1.ops.receiveType(type.name, kind, selector.type)}(msg);`);
                    // Exit
                    ctx.append('return (self, true);');
                });
                ctx.append(`}`);
            }
            if (selector.kind === (internal ? 'internal-empty' : 'external-empty')) {
                ctx.append();
                ctx.append(`;; Receive empty message`);
                ctx.append(`if ((op == 0) & (slice_bits(in_msg) <= 32)) {`);
                ctx.inIndent(() => {
                    // Execute function
                    ctx.append(`self~${ops_1.ops.receiveEmpty(type.name, kind)}();`);
                    // Exit
                    ctx.append('return (self, true);');
                });
                ctx.append(`}`);
            }
        }
        // Text resolvers
        let hasComments = !!type.receivers.find((v) => internal ? (v.selector.kind === 'internal-comment' || v.selector.kind === 'internal-comment-fallback') : (v.selector.kind === 'external-comment' || v.selector.kind === 'external-comment-fallback'));
        if (hasComments) {
            ctx.append();
            ctx.append(`;; Text Receivers`);
            ctx.append(`if (op == 0) {`);
            ctx.inIndent(() => {
                if (!!type.receivers.find((v) => v.selector.kind === (internal ? 'internal-comment' : 'external-comment'))) {
                    ctx.append(`var text_op = slice_hash(in_msg);`);
                    for (const r of type.receivers) {
                        const selector = r.selector;
                        if (selector.kind === (internal ? 'internal-comment' : 'external-comment')) {
                            let hash = (0, ton_core_1.beginCell)()
                                .storeUint(0, 32)
                                .storeBuffer(Buffer.from(selector.comment, 'utf8'))
                                .endCell()
                                .hash()
                                .toString('hex', 0, 64);
                            ctx.append();
                            ctx.append(`;; Receive "${selector.comment}" message`);
                            ctx.append(`if (text_op == 0x${hash}) {`);
                            ctx.inIndent(() => {
                                // Execute function
                                ctx.append(`self~${ops_1.ops.receiveText(type.name, kind, hash)}();`);
                                // Exit
                                ctx.append('return (self, true);');
                            });
                            ctx.append(`}`);
                        }
                    }
                }
                // Comment fallback resolver
                let fallback = type.receivers.find((v) => v.selector.kind === (internal ? 'internal-comment-fallback' : 'external-comment-fallback'));
                if (fallback) {
                    ctx.append(`if (slice_bits(in_msg) >= 32) {`);
                    ctx.inIndent(() => {
                        // Execute function
                        ctx.append(`self~${ops_1.ops.receiveAnyText(type.name, kind)}(in_msg.skip_bits(32));`);
                        // Exit
                        ctx.append('return (self, true);');
                    });
                    ctx.append(`}`);
                }
            });
            ctx.append(`}`);
        }
        // Fallback
        let fallbackReceiver = type.receivers.find((v) => v.selector.kind === (internal ? 'internal-fallback' : 'external-fallback'));
        if (fallbackReceiver) {
            ctx.append();
            ctx.append(`;; Receiver fallback`);
            // Execute function
            ctx.append(`self~${ops_1.ops.receiveAny(type.name, kind)}(in_msg);`);
            ctx.append('return (self, true);');
        }
        else {
            ctx.append();
            ctx.append('return (self, false);');
        }
    });
    ctx.append(`}`);
    ctx.append();
}
exports.writeRouter = writeRouter;
function writeReceiver(self, f, ctx) {
    const selector = f.selector;
    let selfRes = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx);
    let selfType = (0, resolveFuncType_1.resolveFuncType)(self, ctx);
    let selfUnpack = `var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(self, (0, id_1.id)('self'), ctx)} = ${(0, id_1.id)('self')};`;
    // Binary receiver
    if (selector.kind === 'internal-binary' || selector.kind === 'external-binary') {
        let args = [
            selfType + ' ' + (0, id_1.id)('self'),
            (0, resolveFuncType_1.resolveFuncType)(selector.type, ctx) + ' ' + (0, id_1.id)(selector.name)
        ];
        ctx.append(`((${selfType}), ()) ${ops_1.ops.receiveType(self.name, selector.kind === 'internal-binary' ? 'internal' : 'external', selector.type)}(${args.join(', ')}) impure inline {`);
        ctx.inIndent(() => {
            ctx.append(selfUnpack);
            ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(selector.type, (0, id_1.id)(selector.name), ctx)} = ${(0, id_1.id)(selector.name)};`);
            for (let s of f.ast.statements) {
                (0, writeFunction_1.writeStatement)(s, selfRes, null, ctx);
            }
            if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }
    // Empty receiver
    if (selector.kind === 'internal-empty' || selector.kind === 'external-empty') {
        ctx.append(`((${selfType}), ()) ${ops_1.ops.receiveEmpty(self.name, selector.kind === 'internal-empty' ? 'internal' : 'external')}(${(selfType + ' ' + (0, id_1.id)('self'))}) impure inline {`);
        ctx.inIndent(() => {
            ctx.append(selfUnpack);
            for (let s of f.ast.statements) {
                (0, writeFunction_1.writeStatement)(s, selfRes, null, ctx);
            }
            if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }
    // Comment receiver
    if (selector.kind === 'internal-comment' || selector.kind === 'external-comment') {
        let hash = (0, ton_core_1.beginCell)()
            .storeUint(0, 32)
            .storeBuffer(Buffer.from(selector.comment, 'utf8'))
            .endCell()
            .hash()
            .toString('hex', 0, 64);
        ctx.append(`(${selfType}, ()) ${ops_1.ops.receiveText(self.name, selector.kind === 'internal-comment' ? 'internal' : 'external', hash)}(${(selfType + ' ' + (0, id_1.id)('self'))}) impure inline {`);
        ctx.inIndent(() => {
            ctx.append(selfUnpack);
            for (let s of f.ast.statements) {
                (0, writeFunction_1.writeStatement)(s, selfRes, null, ctx);
            }
            if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }
    // Fallback
    if (selector.kind === 'internal-comment-fallback' || selector.kind === 'external-comment-fallback') {
        ctx.append(`(${selfType}, ()) ${ops_1.ops.receiveAnyText(self.name, selector.kind === 'internal-comment-fallback' ? 'internal' : 'external')}(${([selfType + ' ' + (0, id_1.id)('self'), 'slice ' + (0, id_1.id)(selector.name)]).join(', ')}) impure inline {`);
        ctx.inIndent(() => {
            ctx.append(selfUnpack);
            for (let s of f.ast.statements) {
                (0, writeFunction_1.writeStatement)(s, selfRes, null, ctx);
            }
            if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }
    // Fallback
    if (selector.kind === 'internal-fallback') {
        ctx.append(`(${selfType}, ()) ${ops_1.ops.receiveAny(self.name, selector.kind === 'internal-fallback' ? 'internal' : 'external')}(${selfType} ${(0, id_1.id)('self')}, slice ${(0, id_1.id)(selector.name)}) impure inline {`);
        ctx.inIndent(() => {
            ctx.append(selfUnpack);
            for (let s of f.ast.statements) {
                (0, writeFunction_1.writeStatement)(s, selfRes, null, ctx);
            }
            if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }
    // Bounced
    if (selector.kind === 'bounce-fallback') {
        ctx.append(`(${selfType}, ()) ${ops_1.ops.receiveBounceAny(self.name)}(${selfType} ${(0, id_1.id)('self')}, slice ${(0, id_1.id)(selector.name)}) impure inline {`);
        ctx.inIndent(() => {
            ctx.append(selfUnpack);
            for (let s of f.ast.statements) {
                (0, writeFunction_1.writeStatement)(s, selfRes, null, ctx);
            }
            if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }
    if (selector.kind === 'bounce-binary') {
        let args = [
            selfType + ' ' + (0, id_1.id)('self'),
            (0, resolveFuncType_1.resolveFuncType)(selector.type, ctx, false, selector.bounced) + ' ' + (0, id_1.id)(selector.name)
        ];
        ctx.append(`((${selfType}), ()) ${ops_1.ops.receiveTypeBounce(self.name, selector.type)}(${args.join(', ')}) impure inline {`);
        ctx.inIndent(() => {
            ctx.append(selfUnpack);
            ctx.append(`var ${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(selector.type, (0, id_1.id)(selector.name), ctx, false, selector.bounced)} = ${(0, id_1.id)(selector.name)};`);
            for (let s of f.ast.statements) {
                (0, writeFunction_1.writeStatement)(s, selfRes, null, ctx);
            }
            if (f.ast.statements.length === 0 || f.ast.statements[f.ast.statements.length - 1].kind !== 'statement_return') {
                ctx.append(`return (${selfRes}, ());`);
            }
        });
        ctx.append(`}`);
        ctx.append();
        return;
    }
}
exports.writeReceiver = writeReceiver;
