"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveFuncTypeFromAbiUnpack = void 0;
const resolveDescriptors_1 = require("../../types/resolveDescriptors");
function resolveFuncTypeFromAbiUnpack(name, fields, ctx) {
    if (fields.length === 0) {
        return `${name}`;
    }
    let res = [];
    for (let f of fields) {
        if (f.type.kind === 'dict') {
            res.push(`${name}'${f.name}`);
        }
        else if (f.type.kind === 'simple') {
            if (f.type.type === 'int' || f.type.type === 'uint' || f.type.type === 'bool') {
                res.push(`${name}'${f.name}`);
            }
            else if (f.type.type === 'cell') {
                res.push(`${name}'${f.name}`);
            }
            else if (f.type.type === 'slice') {
                res.push(`${name}'${f.name}`);
            }
            else if (f.type.type === 'builder') {
                res.push(`${name}'${f.name}`);
            }
            else if (f.type.type === 'address') {
                res.push(`${name}'${f.name}`);
            }
            else if (f.type.type === 'fixed-bytes') {
                res.push(`${name}'${f.name}`);
            }
            else if (f.type.type === 'string') {
                res.push(`${name}'${f.name}`);
            }
            else {
                let t = (0, resolveDescriptors_1.getType)(ctx.ctx, f.type.type);
                if (f.type.optional || t.fields.length === 0) {
                    res.push(`${name}'${f.name}`);
                }
                else {
                    let loaded = t.fields.map((v) => v.abi);
                    res.push(resolveFuncTypeFromAbiUnpack(`${name}'${f.name}`, loaded, ctx));
                }
            }
        }
        else {
            throw Error('Unsupported type');
        }
    }
    return `(${res.join(', ')})`;
}
exports.resolveFuncTypeFromAbiUnpack = resolveFuncTypeFromAbiUnpack;
