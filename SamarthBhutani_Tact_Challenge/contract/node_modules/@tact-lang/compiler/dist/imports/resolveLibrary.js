"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveLibrary = void 0;
const parseImportPath_1 = require("./parseImportPath");
function resolveLibrary(args) {
    // Stdlib resolving
    // NOTE: We are handling stdlib resolving here, because we need to enforce the stdlib import before anything else
    //       to avoid hijacking the stdlib imports
    if (args.name.startsWith('@stdlib/')) {
        let libraryName = args.name.substring('@stdlib/'.length);
        let libraryPath = (0, parseImportPath_1.parseImportPath)('./' + libraryName + '.tact');
        if (!libraryPath) {
            return { ok: false };
        }
        let tactFile = args.stdlib.resolve('libs', ...libraryPath);
        if (args.stdlib.exists(tactFile)) {
            return { ok: true, path: tactFile, source: 'stdlib', kind: 'tact' };
        }
        else {
            return { ok: false };
        }
    }
    // Resolve vfs
    let vfs;
    let source;
    if (args.path.startsWith(args.stdlib.root)) { // NOTE: stdlib checked first to avoid hijacking stdlib imports
        vfs = args.stdlib;
        source = 'stdlib';
    }
    else if (args.path.startsWith(args.project.root)) {
        vfs = args.project;
        source = 'project';
    }
    else {
        return { ok: false };
    }
    let workingDirectory = args.path.slice(vfs.root.length);
    // Resolving relative file
    let importName = args.name;
    let kind = importName.endsWith('.fc') ? 'func' : 'tact';
    if (!importName.endsWith('.tact') && !importName.endsWith('.fc')) {
        importName = importName + '.tact';
    }
    // Resolve import
    let parsedImport = (0, parseImportPath_1.parseImportPath)(importName);
    if (!parsedImport) {
        return { ok: false };
    }
    let resolvedPath = vfs.resolve(workingDirectory, '..', ...parsedImport);
    if (vfs.exists(resolvedPath)) {
        return { ok: true, path: resolvedPath, source, kind };
    }
    // Nothing matched
    return { ok: false };
}
exports.resolveLibrary = resolveLibrary;
