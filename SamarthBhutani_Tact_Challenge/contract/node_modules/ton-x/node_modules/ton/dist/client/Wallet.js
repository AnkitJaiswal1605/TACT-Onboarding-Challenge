"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _Wallet_client, _Wallet_contract;
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = exports.validateWalletType = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const ton_crypto_1 = require("ton-crypto");
const __1 = require("..");
const WalletV1R2Source_1 = require("../contracts/sources/WalletV1R2Source");
const WalletV1R3Source_1 = require("../contracts/sources/WalletV1R3Source");
const WalletV2R1Source_1 = require("../contracts/sources/WalletV2R1Source");
const WalletV2R2Source_1 = require("../contracts/sources/WalletV2R2Source");
const WalletV3R1Source_1 = require("../contracts/sources/WalletV3R1Source");
const WalletV3R2Source_1 = require("../contracts/sources/WalletV3R2Source");
const WalletContract_1 = require("../contracts/WalletContract");
const CommonMessageInfo_1 = require("../messages/CommonMessageInfo");
const InternalMessage_1 = require("../messages/InternalMessage");
const SendMode_1 = require("./SendMode");
// Wallet Contract Priority
const allTypes = [
    'org.ton.wallets.simple.r2',
    'org.ton.wallets.simple.r3',
    'org.ton.wallets.v2',
    'org.ton.wallets.v2.r2',
    'org.ton.wallets.v3.r2',
    'org.ton.wallets.v3'
];
function validateWalletType(src) {
    if (src === 'org.ton.wallets.simple'
        || src === 'org.ton.wallets.simple.r2'
        || src === 'org.ton.wallets.simple.r3'
        || src === 'org.ton.wallets.v2'
        || src === 'org.ton.wallets.v2.r2'
        || src === 'org.ton.wallets.v3'
        || src === 'org.ton.wallets.v3.r2') {
        return src;
    }
    return null;
}
exports.validateWalletType = validateWalletType;
function createContract(client, type, publicKey, workchain) {
    if (type === 'org.ton.wallets.simple') {
        throw Error('Unsupported wallet');
    }
    else if (type === 'org.ton.wallets.simple.r2') {
        return WalletContract_1.WalletContract.create(client, WalletV1R2Source_1.WalletV1R2Source.create({ publicKey, workchain }));
    }
    else if (type === 'org.ton.wallets.simple.r3') {
        return WalletContract_1.WalletContract.create(client, WalletV1R3Source_1.WalletV1R3Source.create({ publicKey, workchain }));
    }
    else if (type === 'org.ton.wallets.v2') {
        return WalletContract_1.WalletContract.create(client, WalletV2R1Source_1.WalletV2R1Source.create({ publicKey, workchain }));
    }
    else if (type === 'org.ton.wallets.v2.r2') {
        return WalletContract_1.WalletContract.create(client, WalletV2R2Source_1.WalletV2R2Source.create({ publicKey, workchain }));
    }
    else if (type === 'org.ton.wallets.v3') {
        return WalletContract_1.WalletContract.create(client, WalletV3R1Source_1.WalletV3R1Source.create({ publicKey, workchain }));
    }
    else if (type === 'org.ton.wallets.v3.r2') {
        return WalletContract_1.WalletContract.create(client, WalletV3R2Source_1.WalletV3R2Source.create({ publicKey, workchain }));
    }
    else {
        throw Error('Unknown wallet type: ' + type);
    }
}
class Wallet {
    constructor(client, address) {
        _Wallet_client.set(this, void 0);
        _Wallet_contract.set(this, null);
        __classPrivateFieldSet(this, _Wallet_client, client, "f");
        this.address = address;
    }
    static open(client, address) {
        return new Wallet(client, address);
    }
    static openDefault(client, workchain, secretKey) {
        const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let c = createContract(client, 'org.ton.wallets.v3', publicKey, workchain);
        let w = new Wallet(client, c.address);
        w.prepare(workchain, publicKey, 'org.ton.wallets.v3');
        return w;
    }
    static openByType(client, workchain, secretKey, type) {
        const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let c = createContract(client, type, publicKey, workchain);
        let w = new Wallet(client, c.address);
        w.prepare(workchain, publicKey, type);
        return w;
    }
    static openFromSource(client, source) {
        let address = (0, __1.contractAddress)(source);
        let w = new Wallet(client, address);
        w.prepareFromSource(source);
        return w;
    }
    static async findActiveBySecretKey(client, workchain, secretKey) {
        const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let types = [];
        for (let type of allTypes) {
            let contra = createContract(client, type, publicKey, workchain);
            let deployed = await client.isContractDeployed(contra.address);
            let balance = await client.getBalance(contra.address);
            if (deployed || balance.gt(new bn_js_1.default(0))) {
                types.push({ address: contra.address, type, balance, deployed });
            }
        }
        return types;
    }
    static async findBestBySecretKey(client, workchain, secretKey) {
        const publicKey = (0, ton_crypto_1.keyPairFromSecretKey)(secretKey).publicKey;
        let allActive = await this.findActiveBySecretKey(client, workchain, secretKey);
        // Create default one if no wallet exists
        if (allActive.length === 0) {
            return this.openDefault(client, workchain, secretKey);
        }
        // Try to match with biggest balance
        let maxBalance = allActive[0].balance;
        let bestContract = allActive[0].type;
        for (let i = 1; i < allActive.length; i++) {
            let ac = allActive[i];
            // Contracts are sorted by priority
            if (ac.balance.gte(maxBalance)) {
                maxBalance = ac.balance;
                bestContract = ac.type;
            }
        }
        if (maxBalance.gt(new bn_js_1.default(0))) {
            let c = createContract(client, bestContract, publicKey, workchain);
            ;
            let w = new Wallet(client, c.address);
            w.prepare(workchain, publicKey, bestContract);
            return w;
        }
        // Return last (as most recent)
        let c = createContract(client, allActive[allActive.length - 1].type, publicKey, workchain);
        let w = new Wallet(client, c.address);
        w.prepare(workchain, publicKey, allActive[allActive.length - 1].type);
        return w;
    }
    get prepared() {
        return !!__classPrivateFieldGet(this, _Wallet_contract, "f");
    }
    async getSeqNo() {
        if (await __classPrivateFieldGet(this, _Wallet_client, "f").isContractDeployed(this.address)) {
            let res = await __classPrivateFieldGet(this, _Wallet_client, "f").callGetMethod(this.address, 'seqno');
            return parseInt(res.stack[0][1], 16);
        }
        else {
            return 0;
        }
    }
    prepare(workchain, publicKey, type = 'org.ton.wallets.v3') {
        let contra = createContract(__classPrivateFieldGet(this, _Wallet_client, "f"), type, publicKey, workchain);
        if (!contra.address.equals(this.address)) {
            throw Error('Contract have different address');
        }
        __classPrivateFieldSet(this, _Wallet_contract, contra, "f");
    }
    prepareFromSource(source) {
        let contra = WalletContract_1.WalletContract.create(__classPrivateFieldGet(this, _Wallet_client, "f"), source);
        if (!contra.address.equals(this.address)) {
            throw Error('Contract have different address');
        }
        __classPrivateFieldSet(this, _Wallet_contract, contra, "f");
    }
    /**
     * Transfers value to specified address
     */
    async transfer(args) {
        const contract = __classPrivateFieldGet(this, _Wallet_contract, "f");
        if (!contract) {
            throw Error('Please, prepare wallet first');
        }
        // Resolve payload
        let payload = null;
        if (args.payload) {
            if (typeof args.payload === 'string') {
                payload = new __1.CommentMessage(args.payload);
            }
            else if (Buffer.isBuffer(args.payload)) {
                payload = new __1.BinaryMessage(args.payload);
            }
        }
        // Check transfer
        const transfer = await contract.createTransfer({
            secretKey: args.secretKey,
            seqno: args.seqno,
            sendMode: args.sendMode || (SendMode_1.SendMode.IGNORE_ERRORS + SendMode_1.SendMode.PAY_GAS_SEPARATLY),
            timeout: args.timeout,
            order: new InternalMessage_1.InternalMessage({
                to: args.to,
                value: args.value,
                bounce: args.bounce,
                body: new CommonMessageInfo_1.CommonMessageInfo({ body: payload })
            })
        });
        // Send
        await __classPrivateFieldGet(this, _Wallet_client, "f").sendExternalMessage(contract, transfer);
    }
    /**
     * Signing transfer request. Could be done offline.
     * @param args sign
     * @returns
     */
    transferSign(args) {
        const contract = __classPrivateFieldGet(this, _Wallet_contract, "f");
        if (!contract) {
            throw Error('Please, prepare wallet first');
        }
        // Resolve payload
        let payload = null;
        if (args.payload) {
            if (typeof args.payload === 'string') {
                payload = new __1.CommentMessage(args.payload);
            }
            else if (Buffer.isBuffer(args.payload)) {
                payload = new __1.BinaryMessage(args.payload);
            }
        }
        // Transfer
        const transfer = contract.createTransfer({
            secretKey: args.secretKey,
            seqno: args.seqno,
            sendMode: args.sendMode || (SendMode_1.SendMode.IGNORE_ERRORS + SendMode_1.SendMode.PAY_GAS_SEPARATLY),
            timeout: args.timeout,
            order: new InternalMessage_1.InternalMessage({
                to: args.to,
                value: args.value,
                bounce: args.bounce,
                body: new CommonMessageInfo_1.CommonMessageInfo({ body: payload })
            })
        });
        // External message
        const message = new __1.ExternalMessage({
            to: contract.address,
            body: new CommonMessageInfo_1.CommonMessageInfo({
                stateInit: new __1.StateInit({ code: contract.source.initialCode, data: contract.source.initialData }),
                body: new __1.CellMessage(transfer)
            })
        });
        const res = new __1.Cell();
        message.writeTo(res);
        return res;
    }
    /**
     * Commit prepared transfer
     * @param transfer signed transfer for commit
     */
    async transferCommit(transfer) {
        await __classPrivateFieldGet(this, _Wallet_client, "f").sendFile(transfer.toBoc({ idx: false }));
    }
}
exports.Wallet = Wallet;
_Wallet_client = new WeakMap(), _Wallet_contract = new WeakMap();
