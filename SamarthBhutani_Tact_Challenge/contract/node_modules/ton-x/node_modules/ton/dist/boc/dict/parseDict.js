"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseDictRefs = exports.parseDictBitString = exports.parseDict = void 0;
const bn_js_1 = require("bn.js");
function doParse(prefix, slice, n, res, extractor) {
    // Reading label
    let lb0 = slice.readBit() ? 1 : 0;
    let prefixLength = 0;
    let pp = prefix;
    if (lb0 === 0) {
        // Short label detected
        // Read 
        prefixLength = slice.readUnaryLength();
        // Read prefix
        for (let i = 0; i < prefixLength; i++) {
            pp += slice.readBit() ? '1' : '0';
        }
    }
    else {
        let lb1 = slice.readBit() ? 1 : 0;
        if (lb1 === 0) {
            // Long label detected
            prefixLength = slice.readUintNumber(Math.ceil(Math.log2(n + 1)));
            for (let i = 0; i < prefixLength; i++) {
                pp += slice.readBit() ? '1' : '0';
            }
        }
        else {
            // Same label detected
            let bit = slice.readBit() ? '1' : '0';
            prefixLength = slice.readUintNumber(Math.ceil(Math.log2(n + 1)));
            for (let i = 0; i < prefixLength; i++) {
                pp += bit;
            }
        }
    }
    if (n - prefixLength === 0) {
        res.set(new bn_js_1.BN(pp, 2).toString(10), extractor(slice));
    }
    else {
        let left = slice.readRef();
        let right = slice.readRef();
        // NOTE: Left and right branches are implicitly contain prefixes '0' and '1'
        doParse(pp + '0', left, n - prefixLength - 1, res, extractor);
        doParse(pp + '1', right, n - prefixLength - 1, res, extractor);
    }
}
function parseDict(slice, keySize, extractor) {
    let res = new Map();
    doParse('', slice, keySize, res, extractor);
    return res;
}
exports.parseDict = parseDict;
function parseDictBitString(slice, keySize) {
    let res = new Map();
    doParse('', slice, keySize, res, (slice) => slice.readRemaining());
    return res;
}
exports.parseDictBitString = parseDictBitString;
function parseDictRefs(slice, keySize) {
    let res = new Map();
    doParse('', slice, keySize, res, (slice) => slice.readRef());
    return res;
}
exports.parseDictRefs = parseDictRefs;
