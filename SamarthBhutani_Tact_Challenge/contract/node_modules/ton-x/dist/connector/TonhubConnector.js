"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonhubConnector = void 0;
const ton_crypto_1 = require("ton-crypto");
const backoff_1 = require("../utils/backoff");
const toURLsafe_1 = require("../utils/toURLsafe");
const t = __importStar(require("io-ts"));
const teslabot_1 = require("teslabot");
const ton_1 = require("ton");
const bn_js_1 = __importDefault(require("bn.js"));
const TonhubHttpTransport_1 = require("../transport/TonhubHttpTransport");
const extractPublicKeyAndAddress_1 = require("../contracts/extractPublicKeyAndAddress");
const crypto_1 = require("./crypto");
const sessionStateCodec = t.union([
    t.type({
        state: t.literal('not_found')
    }),
    t.type({
        state: t.literal('initing'),
        name: t.string,
        url: t.string,
        testnet: t.boolean,
        created: t.number,
        updated: t.number,
        revoked: t.boolean
    }),
    t.type({
        state: t.literal('ready'),
        name: t.string,
        url: t.string,
        wallet: t.type({
            address: t.string,
            endpoint: t.string,
            walletConfig: t.string,
            walletType: t.string,
            walletSig: t.string,
            appPublicKey: t.string
        }),
        testnet: t.boolean,
        created: t.number,
        updated: t.number,
        revoked: t.boolean
    })
]);
const jobStateCodec = t.union([t.type({
        state: t.union([t.literal('submitted'), t.literal('expired'), t.literal('rejected')]),
        job: t.string,
        created: t.number,
        updated: t.number,
        now: t.number
    }), t.type({
        state: t.literal('completed'),
        job: t.string,
        created: t.number,
        updated: t.number,
        result: t.string,
        now: t.number
    }), t.type({
        state: t.literal('empty'),
        now: t.number
    })]);
function idFromSeed(seed) {
    let keyPair = (0, ton_crypto_1.keyPairFromSeed)(Buffer.from(seed, 'base64'));
    return (0, toURLsafe_1.toUrlSafe)(keyPair.publicKey.toString('base64'));
}
function textToCell(src) {
    let bytes = Buffer.from(src);
    let res = new ton_1.Cell();
    let dest = res;
    while (bytes.length > 0) {
        let avaliable = Math.floor(dest.bits.available / 8);
        if (bytes.length <= avaliable) {
            dest.bits.writeBuffer(bytes);
            break;
        }
        dest.bits.writeBuffer(bytes.slice(0, avaliable));
        bytes = bytes.slice(avaliable, bytes.length);
        let nc = new ton_1.Cell();
        dest.refs.push(nc);
        dest = nc;
    }
    return res;
}
class TonhubConnector {
    constructor(args) {
        this.createNewSession = async (args) => {
            // Generate new key
            let seed = await (0, ton_crypto_1.getSecureRandomBytes)(32);
            let keyPair = (0, ton_crypto_1.keyPairFromSeed)(seed);
            let sessionId = (0, toURLsafe_1.toUrlSafe)(keyPair.publicKey.toString('base64'));
            // Request new session
            await (0, backoff_1.backoff)(async () => {
                let session = await this.transport.call('session_new', {
                    key: sessionId,
                    testnet: this.network === 'testnet',
                    name: args.name,
                    url: args.url,
                });
                if (!session.ok) {
                    throw Error('Unable to create state');
                }
            });
            // Return session
            return {
                id: sessionId,
                seed: seed.toString('base64'),
                link: (this.network === 'testnet' ? 'ton-test://connect/' : 'ton://connect/') + sessionId + '?endpoint=connect.tonhubapi.com'
            };
        };
        this.ensureSessionStateCorrect = (sessionId, ex) => {
            if (!sessionStateCodec.is(ex)) {
                throw Error('Invalid response from server');
            }
            if (ex.state === 'initing') {
                if (ex.testnet !== (this.network === 'testnet')) {
                    return { state: 'revoked' };
                }
                return {
                    state: 'initing',
                    name: ex.name,
                    url: ex.url,
                    created: ex.created,
                    updated: ex.updated
                };
            }
            if (ex.state === 'ready') {
                if (ex.revoked) {
                    return { state: 'revoked' };
                }
                if (ex.testnet !== (this.network === 'testnet')) {
                    return { state: 'revoked' };
                }
                if (!TonhubConnector.verifyWalletConfig(sessionId, ex.wallet)) {
                    throw Error('Integrity check failed');
                }
                return {
                    state: 'ready',
                    name: ex.name,
                    url: ex.url,
                    created: ex.created,
                    updated: ex.updated,
                    wallet: {
                        address: ex.wallet.address,
                        endpoint: ex.wallet.endpoint,
                        walletType: ex.wallet.walletType,
                        walletConfig: ex.wallet.walletConfig,
                        walletSig: ex.wallet.walletSig,
                        appPublicKey: ex.wallet.appPublicKey
                    }
                };
            }
            return { state: 'revoked' };
        };
        this.getSessionState = async (sessionId) => {
            return await (0, backoff_1.backoff)(async () => {
                let session = await this.transport.call('session_get', {
                    id: sessionId
                });
                return this.ensureSessionStateCorrect(sessionId, session);
            });
        };
        this.waitForSessionState = async (sessionId, lastUpdated) => {
            return await (0, backoff_1.backoff)(async () => {
                let session = await this.transport.call('session_wait', {
                    id: sessionId,
                    lastUpdated
                });
                return this.ensureSessionStateCorrect(sessionId, session);
            });
        };
        this.awaitSessionReady = async (sessionId, timeout, lastUpdated) => {
            let expires = Date.now() + timeout;
            let res = await (0, backoff_1.backoff)(async () => {
                while (Date.now() < expires) {
                    let existing = await this.waitForSessionState(sessionId, lastUpdated);
                    if (existing.state !== 'initing') {
                        if (existing.state === 'ready') {
                            return existing;
                        }
                        else if (existing.state === 'revoked') {
                            return existing;
                        }
                    }
                    await (0, teslabot_1.delay)(1000);
                }
                return { state: 'expired' };
            });
            return res;
        };
        this.requestTransaction = async (request) => {
            const sessionId = idFromSeed(request.seed);
            // Check session
            let session = await (0, backoff_1.backoff)(() => this.getSessionState(sessionId));
            if (session.state !== 'ready') {
                return { type: 'invalid_session' };
            }
            if (session.wallet.appPublicKey !== request.appPublicKey) {
                return { type: 'invalid_session' };
            }
            // Parse address
            let address = ton_1.Address.parseFriendly(request.to).address;
            // Value
            let value = new bn_js_1.default(request.value, 10);
            // Parse data
            let data = null;
            if (typeof request.payload === 'string') {
                data = ton_1.Cell.fromBoc(Buffer.from(request.payload, 'base64'))[0];
            }
            // StateInit
            let stateInit = null;
            if (typeof request.stateInit === 'string') {
                stateInit = ton_1.Cell.fromBoc(Buffer.from(request.stateInit, 'base64'))[0];
            }
            // Comment
            let comment = '';
            if (typeof request.text === 'string') {
                comment = request.text;
            }
            // Prepare cell
            let expires = Math.floor((Date.now() + request.timeout) / 1000);
            const job = (0, ton_1.beginCell)()
                .storeBuffer(Buffer.from(session.wallet.appPublicKey, 'base64'))
                .storeUint(expires, 32)
                .storeCoins(0)
                .storeRef((0, ton_1.beginCell)()
                .storeAddress(address)
                .storeCoins(value)
                .storeRef(textToCell(comment))
                .storeRefMaybe(data ? data : null)
                .storeRefMaybe(stateInit ? stateInit : null)
                .endCell())
                .endCell();
            // Sign
            let keypair = (0, ton_crypto_1.keyPairFromSeed)(Buffer.from(request.seed, 'base64'));
            let signature = (0, ton_1.safeSign)(job, keypair.secretKey);
            // Create package
            let pkg = (0, ton_1.beginCell)()
                .storeBuffer(signature)
                .storeBuffer(keypair.publicKey)
                .storeRef(job)
                .endCell();
            let boc = pkg.toBoc({ idx: false }).toString('base64');
            // Post command
            await (0, backoff_1.backoff)(() => this.transport.call('command_new', {
                job: boc,
            }));
            // Await result
            let result = await this._awaitJobState(request.appPublicKey, boc);
            if (result.type === 'completed') {
                return { type: 'success', response: result.result };
            }
            else if (result.type === 'rejected') {
                return { type: 'rejected' };
            }
            return { type: 'expired' };
        };
        this.requestSign = async (request) => {
            const sessionId = idFromSeed(request.seed);
            // Check session
            let session = await (0, backoff_1.backoff)(() => this.getSessionState(sessionId));
            if (session.state !== 'ready') {
                return { type: 'invalid_session' };
            }
            if (session.wallet.appPublicKey !== request.appPublicKey) {
                return { type: 'invalid_session' };
            }
            // Parse data
            let data = new ton_1.Cell();
            if (typeof request.payload === 'string') {
                data = ton_1.Cell.fromBoc(Buffer.from(request.payload, 'base64'))[0];
            }
            // Comment
            let comment = '';
            if (typeof request.text === 'string') {
                comment = request.text;
            }
            // Prepare cell
            let expires = Math.floor((Date.now() + request.timeout) / 1000);
            let commentCell = new ton_1.Cell();
            new ton_1.CommentMessage(comment).writeTo(commentCell);
            const job = (0, ton_1.beginCell)()
                .storeBuffer(Buffer.from(session.wallet.appPublicKey, 'base64'))
                .storeUint(expires, 32)
                .storeCoins(1)
                .storeRef((0, ton_1.beginCell)()
                .storeRef(commentCell)
                .storeRef(data)
                .endCell())
                .endCell();
            // Sign
            let keypair = (0, ton_crypto_1.keyPairFromSeed)(Buffer.from(request.seed, 'base64'));
            let signature = (0, ton_1.safeSign)(job, keypair.secretKey);
            // Create package
            let pkg = (0, ton_1.beginCell)()
                .storeBuffer(signature)
                .storeBuffer(keypair.publicKey)
                .storeRef(job)
                .endCell();
            let boc = pkg.toBoc({ idx: false }).toString('base64');
            // Post command
            await (0, backoff_1.backoff)(() => this.transport.call('command_new', {
                job: boc,
            }));
            // Await result
            let result = await this._awaitJobState(request.appPublicKey, boc);
            if (result.type === 'completed') {
                const cellRes = ton_1.Cell.fromBoc(Buffer.from(result.result, 'base64'))[0];
                let slice = cellRes.beginParse();
                const resSignature = slice.readBuffer(64);
                let correct = (0, crypto_1.verifySignatureResponse)({
                    signature: resSignature.toString('base64'),
                    config: session.wallet,
                    payload: request.payload,
                    text: request.text,
                });
                if (correct) {
                    return { type: 'success', signature: resSignature.toString('base64') };
                }
                else {
                    return { type: 'rejected' };
                }
            }
            else if (result.type === 'rejected') {
                return { type: 'rejected' };
            }
            return { type: 'expired' };
        };
        this._awaitJobState = async (appPublicKey, boc) => {
            return await (0, backoff_1.backoff)(async () => {
                while (true) {
                    let state = await this._getJobState(appPublicKey, boc);
                    if (state.type === 'expired') {
                        return { type: 'expired' };
                    }
                    if (state.type === 'completed') {
                        return { type: 'completed', result: state.result };
                    }
                    if (state.type === 'rejected') {
                        return { type: 'rejected' };
                    }
                    await (0, teslabot_1.delay)(1000);
                }
            });
        };
        this._getJobState = async (appPublicKey, boc) => {
            let appk = (0, toURLsafe_1.toUrlSafe)(appPublicKey);
            let res = await this.transport.call('command_get', { appk });
            if (!jobStateCodec.is(res)) {
                throw Error('Invalid response from server');
            }
            if (res.state === 'empty') {
                return { type: 'expired' };
            }
            if (res.job !== boc) {
                return { type: 'rejected' };
            }
            if (res.state === 'expired') {
                return { type: 'expired' };
            }
            if (res.state === 'submitted') {
                return { type: 'submitted' };
            }
            if (res.state === 'rejected') {
                return { type: 'rejected' };
            }
            if (res.state === 'completed') {
                return { type: 'completed', result: res.result };
            }
            throw Error('Invalid response from server');
        };
        let network = 'mainnet';
        if (args) {
            if (args.network !== undefined) {
                network = args.network;
            }
        }
        this.network = network;
        this.transport = (args === null || args === void 0 ? void 0 : args.transport) || new TonhubHttpTransport_1.TonhubHttpTransport();
    }
    static verifyWalletConfig(session, config) {
        // Check address
        const address = ton_1.Address.parseFriendly(config.address).address;
        // Extract public key and address
        let extracted = (0, extractPublicKeyAndAddress_1.extractPublicKeyAndAddress)(config);
        if (!extracted) {
            return false;
        }
        // Check address
        if (!extracted.address.equals(address)) {
            return false;
        }
        let publicKey = extracted.publicKey;
        // Check signature
        let toSign = (0, ton_1.beginCell)()
            .storeCoins(0)
            .storeBuffer(Buffer.from(session, 'base64'))
            .storeAddress(address)
            // Endpoint
            .storeBit(1)
            .storeRef((0, ton_1.beginCell)()
            .storeBuffer(Buffer.from(config.endpoint))
            .endCell())
            // App Public Key
            .storeRef((0, ton_1.beginCell)()
            .storeBuffer(Buffer.from(config.appPublicKey, 'base64'))
            .endCell())
            .endCell();
        // Sign
        return (0, ton_1.safeSignVerify)(toSign, Buffer.from(config.walletSig, 'base64'), publicKey);
    }
}
exports.TonhubConnector = TonhubConnector;
