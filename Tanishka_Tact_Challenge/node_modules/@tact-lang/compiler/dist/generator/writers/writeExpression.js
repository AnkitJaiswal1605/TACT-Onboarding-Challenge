"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeExpression = exports.writeValue = void 0;
const ast_1 = require("../../grammar/ast");
const resolveExpression_1 = require("../../types/resolveExpression");
const resolveDescriptors_1 = require("../../types/resolveDescriptors");
const types_1 = require("../../types/types");
const resolveFuncTypeUnpack_1 = require("./resolveFuncTypeUnpack");
const map_1 = require("../../abi/map");
const global_1 = require("../../abi/global");
const id_1 = require("./id");
const struct_1 = require("../../abi/struct");
const resolveFuncType_1 = require("./resolveFuncType");
const ton_core_1 = require("ton-core");
const writeConstant_1 = require("./writeConstant");
const ops_1 = require("./ops");
const tryExpressionIntrinsics_1 = require("../intrinsics/tryExpressionIntrinsics");
const writeFunction_1 = require("./writeFunction");
function isNull(f) {
    if (f.kind === 'null') {
        return true;
    }
    return false;
}
function tryExtractPath(f) {
    if (f.kind === 'id') {
        return [f.value];
    }
    if (f.kind === 'op_field') {
        let p = tryExtractPath(f.src);
        if (p) {
            return [...p, f.name];
        }
        else {
            return null;
        }
    }
    return null;
}
function writeStructConstructor(type, args, ctx) {
    // Check for duplicates
    let name = ops_1.ops.typeContsturctor(type.name, args, ctx);
    let renderKey = '$constructor$' + type.name + '$' + args.join(',');
    if (ctx.isRendered(renderKey)) {
        return name;
    }
    ctx.markRendered(renderKey);
    // Generate constructor
    ctx.fun(name, () => {
        const sig = `(${(0, resolveFuncType_1.resolveFuncType)(type, ctx)}) ${name}(${args.map((v) => (0, resolveFuncType_1.resolveFuncType)(type.fields.find((v2) => v2.name === v).type, ctx) + ' ' + v).join(', ')})`;
        ctx.signature(sig);
        ctx.flag('inline');
        ctx.context('type:' + type.name);
        ctx.body(() => {
            // Create expressions
            let expressions = type.fields.map((v) => {
                let arg = args.find((v2) => v2 === v.name);
                if (arg) {
                    return arg;
                }
                else if (v.default !== undefined) {
                    return writeValue(v.default, ctx);
                }
                else {
                    throw Error(`Missing argument for field "${v.name}" in struct "${type.name}"`); // Must not happen
                }
            }, ctx);
            ctx.append(`return (${expressions.join(', ')});`);
        });
    });
    return name;
}
function writeValue(s, ctx) {
    if (typeof s === 'bigint') {
        return s.toString(10);
    }
    if (typeof s === 'string') {
        let id = (0, writeConstant_1.writeString)(s, ctx);
        ctx.used(id);
        return `${id}()`;
    }
    if (typeof s === 'boolean') {
        return s ? 'true' : 'false';
    }
    if (ton_core_1.Address.isAddress(s)) {
        let res = (0, writeConstant_1.writeAddress)(s, ctx);
        ctx.used(res);
        return res + '()';
    }
    if (s instanceof ton_core_1.Cell) {
        let res = (0, writeConstant_1.writeCell)(s, ctx);
        ctx.used(res);
        return `${res}()`;
    }
    if (s === null) {
        return 'null()';
    }
    throw Error('Invalid value');
}
exports.writeValue = writeValue;
function writeExpression(f, ctx) {
    //
    // Try intrinsics
    //
    let intrinsic = (0, tryExpressionIntrinsics_1.tryExpressionIntrinsics)(f, ctx);
    if (intrinsic) {
        return intrinsic;
    }
    //
    // Boolean
    //
    if (f.kind === 'boolean') {
        return f.value ? 'true' : 'false';
    }
    //
    // Number
    //
    if (f.kind === 'number') {
        return f.value.toString(10);
    }
    //
    // String literal
    //
    if (f.kind === 'string') {
        let id = (0, writeConstant_1.writeString)(f.value, ctx);
        ctx.used(id);
        return `${id}()`;
    }
    //
    // Null
    //
    if (f.kind === 'null') {
        return 'null()';
    }
    //
    // ID Reference
    //
    if (f.kind === 'id') {
        let t = (0, resolveExpression_1.getExpType)(ctx.ctx, f);
        // Handle packed type
        if (t.kind === 'ref') {
            let tt = (0, resolveDescriptors_1.getType)(ctx.ctx, t.name);
            if (tt.kind === 'contract' || tt.kind === 'struct') {
                return (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, (0, id_1.id)(f.value), ctx);
            }
        }
        if (t.kind === 'ref_bounced') {
            let tt = (0, resolveDescriptors_1.getType)(ctx.ctx, t.name);
            if (tt.kind === 'struct') {
                return (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, (0, id_1.id)(f.value), ctx, false, true);
            }
        }
        // Handle constant
        if ((0, resolveDescriptors_1.hasStaticConstant)(ctx.ctx, f.value)) {
            let c = (0, resolveDescriptors_1.getStaticConstant)(ctx.ctx, f.value);
            return writeValue(c.value, ctx);
        }
        return (0, id_1.id)(f.value);
    }
    //
    // Binary operations: *, /, +, -, ||, &&, ==, !=, <, <=, >, >=
    // NOTE: We always wrap in parenthesis to avoid operator precedence issues
    //
    if (f.kind === 'op_binary') {
        // Special case for non-integer types and nullable
        if (f.op === '==' || f.op === '!=') {
            if (isNull(f.left) && isNull(f.right)) {
                if (f.op === '==') {
                    return 'true';
                }
                else {
                    return 'false';
                }
            }
            else if (isNull(f.left) && !isNull(f.right)) {
                if (f.op === '==') {
                    return `null?(${writeExpression(f.right, ctx)})`;
                }
                else {
                    return `(~ null?(${writeExpression(f.right, ctx)}))`;
                }
            }
            else if (!isNull(f.left) && isNull(f.right)) {
                if (f.op === '==') {
                    return `null?(${writeExpression(f.left, ctx)})`;
                }
                else {
                    return `(~ null?(${writeExpression(f.left, ctx)}))`;
                }
            }
        }
        // Special case for address
        let lt = (0, resolveExpression_1.getExpType)(ctx.ctx, f.left);
        let rt = (0, resolveExpression_1.getExpType)(ctx.ctx, f.right);
        // Case for addresses equality
        if (lt.kind === 'ref' &&
            rt.kind === 'ref' &&
            lt.name === 'Address' &&
            rt.name === 'Address') {
            let prefix = '';
            if (f.op == '!=') {
                prefix = '~ ';
            }
            if (lt.optional && rt.optional) {
                ctx.used(`__tact_slice_eq_bits_nullable`);
                return `( ${prefix}__tact_slice_eq_bits_nullable(${writeExpression(f.left, ctx)}, ${writeExpression(f.right, ctx)}) )`;
            }
            if (lt.optional && !rt.optional) {
                ctx.used(`__tact_slice_eq_bits_nullable_one`);
                return `( ${prefix}__tact_slice_eq_bits_nullable_one(${writeExpression(f.left, ctx)}, ${writeExpression(f.right, ctx)}) )`;
            }
            if (!lt.optional && rt.optional) {
                ctx.used(`__tact_slice_eq_bits_nullable_one`);
                return `( ${prefix}__tact_slice_eq_bits_nullable_one(${writeExpression(f.right, ctx)}, ${writeExpression(f.left, ctx)}) )`;
            }
            ctx.used(`__tact_slice_eq_bits`);
            return `( ${prefix}__tact_slice_eq_bits(${writeExpression(f.right, ctx)}, ${writeExpression(f.left, ctx)}) )`;
        }
        // Case for cells eqality
        if (lt.kind === 'ref' &&
            rt.kind === 'ref' &&
            lt.name === 'Cell' &&
            rt.name === 'Cell') {
            let op = f.op === '==' ? 'eq' : 'neq';
            if (lt.optional && rt.optional) {
                ctx.used(`__tact_cell_${op}_nullable`);
                return `__tact_cell_${op}_nullable(${writeExpression(f.left, ctx)}, ${writeExpression(f.right, ctx)})`;
            }
            if (lt.optional && !rt.optional) {
                ctx.used(`__tact_cell_${op}_nullable_one`);
                return `__tact_cell_${op}_nullable_one(${writeExpression(f.left, ctx)}, ${writeExpression(f.right, ctx)})`;
            }
            if (!lt.optional && rt.optional) {
                ctx.used(`__tact_cell_${op}_nullable_one`);
                return `__tact_cell_${op}_nullable_one(${writeExpression(f.right, ctx)}, ${writeExpression(f.left, ctx)})`;
            }
            ctx.used(`__tact_cell_${op}`);
            return `__tact_cell_${op}(${writeExpression(f.right, ctx)}, ${writeExpression(f.left, ctx)})`;
        }
        // Case for maps eqality
        if (lt.kind === 'map' && rt.kind === 'map') {
            let op = f.op === '==' ? 'eq' : 'neq';
            ctx.used(`__tact_cell_${op}_nullable`);
            return `__tact_cell_${op}_nullable(${writeExpression(f.left, ctx)}, ${writeExpression(f.right, ctx)})`;
        }
        // Check for int or boolean types
        if (lt.kind !== 'ref'
            || rt.kind !== 'ref'
            || (lt.name !== 'Int' && lt.name !== 'Bool')
            || (rt.name !== 'Int' && rt.name !== 'Bool')) {
            throw Error('Invalid types for binary operation'); // Should be unreachable
        }
        // Case for ints equality
        if (f.op === '==' || f.op === '!=') {
            let op = f.op === '==' ? 'eq' : 'neq';
            if (lt.optional && rt.optional) {
                ctx.used(`__tact_int_${op}_nullable`);
                return `__tact_int_${op}_nullable(${writeExpression(f.left, ctx)}, ${writeExpression(f.right, ctx)})`;
            }
            if (lt.optional && !rt.optional) {
                ctx.used(`__tact_int_${op}_nullable_one`);
                return `__tact_int_${op}_nullable_one(${writeExpression(f.left, ctx)}, ${writeExpression(f.right, ctx)})`;
            }
            if (!lt.optional && rt.optional) {
                ctx.used(`__tact_int_${op}_nullable_one`);
                return `__tact_int_${op}_nullable_one(${writeExpression(f.right, ctx)}, ${writeExpression(f.left, ctx)})`;
            }
            if (f.op === '==') {
                return `(${writeExpression(f.left, ctx)} == ${writeExpression(f.right, ctx)})`;
            }
            else {
                return `(${writeExpression(f.left, ctx)} != ${writeExpression(f.right, ctx)})`;
            }
        }
        // Case for "&&" operator
        if (f.op === '&&') {
            return `( (${writeExpression(f.left, ctx)}) ? (${writeExpression(f.right, ctx)}) : (false) )`;
        }
        // Case for "||" operator
        if (f.op === '||') {
            return `( (${writeExpression(f.left, ctx)}) ? (true) : (${writeExpression(f.right, ctx)}) )`;
        }
        // Other ops
        let op;
        if (f.op === '*') {
            op = '*';
        }
        else if (f.op === '/') {
            op = '/';
        }
        else if (f.op === '%') {
            op = '%';
        }
        else if (f.op === '+') {
            op = '+';
        }
        else if (f.op === '-') {
            op = '-';
        }
        else if (f.op === '<') {
            op = '<';
        }
        else if (f.op === '<=') {
            op = '<=';
        }
        else if (f.op === '>') {
            op = '>';
        }
        else if (f.op === '>=') {
            op = '>=';
        }
        else if (f.op === '<<') {
            op = '<<';
        }
        else if (f.op === '>>') {
            op = '>>';
        }
        else if (f.op === '&') {
            op = '&';
        }
        else if (f.op === '|') {
            op = '|';
        }
        else {
            (0, ast_1.throwError)('Unknown binary operator: ' + f.op, f.ref);
        }
        return '(' + writeExpression(f.left, ctx) + ' ' + op + ' ' + writeExpression(f.right, ctx) + ')';
    }
    //
    // Unary operations: !, -, +, !!
    // NOTE: We always wrap in parenthesis to avoid operator precedence issues
    //
    if (f.kind === 'op_unary') {
        // NOTE: Logical not is written as a bitwise not
        if (f.op === '!') {
            return '(~ ' + writeExpression(f.right, ctx) + ')';
        }
        if (f.op === '-') {
            return '(- ' + writeExpression(f.right, ctx) + ')';
        }
        if (f.op === '+') {
            return '(+ ' + writeExpression(f.right, ctx) + ')';
        }
        // NOTE: Assert function that ensures that the value is not null
        if (f.op === '!!') {
            let t = (0, resolveExpression_1.getExpType)(ctx.ctx, f.right);
            if (t.kind === 'ref') {
                let tt = (0, resolveDescriptors_1.getType)(ctx.ctx, t.name);
                if (tt.kind === 'struct') {
                    return `${ops_1.ops.typeNotNull(tt.name, ctx)}(${writeExpression(f.right, ctx)})`;
                }
            }
            ctx.used('__tact_not_null');
            return `${ctx.used('__tact_not_null')}(${writeExpression(f.right, ctx)})`;
        }
        (0, ast_1.throwError)('Unknown unary operator: ' + f.op, f.ref);
    }
    //
    // Field Access
    // NOTE: this branch resolves "a.b", where "a" is an expression and "b" is a field name
    //
    if (f.kind === 'op_field') {
        // Resolve the type of the expression
        let src = (0, resolveExpression_1.getExpType)(ctx.ctx, f.src);
        if (src === null || ((src.kind !== 'ref' || src.optional) && (src.kind !== 'ref_bounced'))) {
            (0, ast_1.throwError)(`Cannot access field of non-struct type: ${(0, types_1.printTypeRef)(src)}`, f.ref);
        }
        let srcT = (0, resolveDescriptors_1.getType)(ctx.ctx, src.name);
        // Resolve field
        let fields;
        fields = srcT.fields;
        if (src.kind === 'ref_bounced') {
            fields = fields.slice(0, srcT.partialFieldCount);
        }
        let field = fields.find((v) => v.name === f.name);
        let cst = srcT.constants.find((v) => v.name === f.name);
        if (!field && !cst) {
            (0, ast_1.throwError)(`Cannot find field "${f.name}" in struct "${srcT.name}"`, f.ref);
        }
        if (field) {
            // Trying to resolve field as a path
            let path = tryExtractPath(f);
            if (path) {
                // Prepare path
                let convertedPath = [];
                convertedPath.push((0, id_1.id)(path[0]));
                convertedPath.push(...path.slice(1));
                let idd = convertedPath.join(`'`);
                // Special case for structs
                if (field.type.kind === 'ref') {
                    let ft = (0, resolveDescriptors_1.getType)(ctx.ctx, field.type.name);
                    if (ft.kind === 'struct' || ft.kind === 'contract') {
                        return (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(field.type, idd, ctx);
                    }
                }
                return idd;
            }
            // Getter instead of direct field access
            return `${ops_1.ops.typeField(srcT.name, field.name, ctx)}(${writeExpression(f.src, ctx)})`;
        }
        else {
            return writeValue(cst.value, ctx);
        }
    }
    //
    // Static Function Call
    //
    if (f.kind === 'op_static_call') {
        // Check global functions
        if (global_1.GlobalFunctions[f.name]) {
            return global_1.GlobalFunctions[f.name].generate(ctx, f.args.map((v) => (0, resolveExpression_1.getExpType)(ctx.ctx, v)), f.args, f.ref);
        }
        let sf = (0, resolveDescriptors_1.getStaticFunction)(ctx.ctx, f.name);
        let n = ops_1.ops.global(f.name);
        if (sf.ast.kind === 'def_native_function') {
            n = sf.ast.nativeName;
            if (n.startsWith('__tact')) {
                ctx.used(n);
            }
        }
        else {
            ctx.used(n);
        }
        return n + '(' + f.args.map((a, i) => (0, writeFunction_1.writeCastedExpression)(a, sf.args[i].type, ctx)).join(', ') + ')';
    }
    //
    // Struct Constructor
    //
    if (f.kind === 'op_new') {
        let src = (0, resolveDescriptors_1.getType)(ctx.ctx, f.type);
        // Write a constructor
        let id = writeStructConstructor(src, f.args.map((v) => v.name), ctx);
        ctx.used(id);
        // Write an expression
        let expressions = f.args.map((v) => (0, writeFunction_1.writeCastedExpression)(v.exp, src.fields.find((v2) => v2.name === v.name).type, ctx), ctx);
        return `${id}(${expressions.join(', ')})`;
    }
    //
    // Object-based function call
    //
    if (f.kind === 'op_call') {
        // Resolve source type
        let src = (0, resolveExpression_1.getExpType)(ctx.ctx, f.src);
        if (src === null) {
            (0, ast_1.throwError)(`Cannot call function of non - direct type: ${(0, types_1.printTypeRef)(src)} `, f.ref);
        }
        // Reference type
        if (src.kind === 'ref') {
            if (src.optional) {
                (0, ast_1.throwError)(`Cannot call function of non - direct type: ${(0, types_1.printTypeRef)(src)} `, f.ref);
            }
            // Render function call
            let t = (0, resolveDescriptors_1.getType)(ctx.ctx, src.name);
            // Check struct ABI
            if (t.kind === 'struct') {
                let abi = struct_1.StructFunctions[f.name];
                if (abi) {
                    return abi.generate(ctx, [src, ...f.args.map((v) => (0, resolveExpression_1.getExpType)(ctx.ctx, v))], [f.src, ...f.args], f.ref);
                }
            }
            // Resolve function
            let ff = t.functions.get(f.name);
            let name = ops_1.ops.extension(src.name, f.name);
            if (ff.ast.kind === 'def_function') {
                ctx.used(name);
            }
            else {
                name = ff.ast.nativeName;
                if (name.startsWith('__tact')) {
                    ctx.used(name);
                }
            }
            // Render arguments
            let renderedArguments = f.args.map((a, i) => (0, writeFunction_1.writeCastedExpression)(a, ff.args[i].type, ctx));
            // Hack to replace a single struct argument to a tensor wrapper since otherwise 
            // func would convert (int) type to just int and break mutating functions
            if (ff.isMutating) {
                if (f.args.length === 1) {
                    let t = (0, resolveExpression_1.getExpType)(ctx.ctx, f.args[0]);
                    if (t.kind === 'ref') {
                        let tt = (0, resolveDescriptors_1.getType)(ctx.ctx, t.name);
                        if ((tt.kind === 'contract' || tt.kind === 'struct') && (ff.args[0].type.kind === 'ref') && (!ff.args[0].type.optional)) {
                            renderedArguments = [`${ops_1.ops.typeTensorCast(tt.name, ctx)}(${renderedArguments[0]})`];
                        }
                    }
                }
            }
            // Render
            let s = writeExpression(f.src, ctx);
            if (ff.isMutating) {
                return `${s}~${name}(${renderedArguments.join(', ')})`;
            }
            else {
                return `${name}(${[s, ...renderedArguments].join(', ')})`;
            }
        }
        // Map types
        if (src.kind === 'map') {
            let abf = map_1.MapFunctions[f.name];
            if (!abf) {
                (0, ast_1.throwError)(`Map function "${f.name}" not found`, f.ref);
            }
            return abf.generate(ctx, [src, ...f.args.map((v) => (0, resolveExpression_1.getExpType)(ctx.ctx, v))], [f.src, ...f.args], f.ref);
        }
        if (src.kind === 'ref_bounced') {
            throw Error("Unimplemented");
        }
        (0, ast_1.throwError)(`Cannot call function of non - direct type: ${(0, types_1.printTypeRef)(src)} `, f.ref);
    }
    //
    // Init of
    //
    if (f.kind === 'init_of') {
        let type = (0, resolveDescriptors_1.getType)(ctx.ctx, f.name);
        return `${ops_1.ops.contractInitChild(f.name, ctx)}(${['__tact_context_sys', ...f.args.map((a, i) => (0, writeFunction_1.writeCastedExpression)(a, type.init.args[i].type, ctx))].join(', ')})`;
    }
    //
    // Unreachable
    //
    throw Error('Unknown expression');
}
exports.writeExpression = writeExpression;
