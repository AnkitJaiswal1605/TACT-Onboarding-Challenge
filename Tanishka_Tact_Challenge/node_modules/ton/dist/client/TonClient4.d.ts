/**
 * Copyright (c) Whales Corp.
 * All Rights Reserved.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/// <reference types="node" />
import { AxiosAdapter } from "axios";
import { Address, Cell, Contract, ContractProvider, Transaction, TupleItem, TupleReader } from "ton-core";
export declare type TonClient4Parameters = {
    /**
     * API endpoint
     */
    endpoint: string;
    /**
     * HTTP request timeout in milliseconds.
     */
    timeout?: number;
    /**
     * HTTP Adapter for axios
     */
    httpAdapter?: AxiosAdapter;
};
export declare class TonClient4 {
    #private;
    constructor(args: TonClient4Parameters);
    /**
     * Get Last Block
     * @returns last block info
     */
    getLastBlock(): Promise<{
        last: {
            workchain: number;
            shard: string;
            seqno: number;
            fileHash: string;
            rootHash: string;
        };
        init: {
            fileHash: string;
            rootHash: string;
        };
        stateRootHash: string;
        now: number;
    }>;
    /**
     * Get block info
     * @param seqno block sequence number
     * @returns block info
     */
    getBlock(seqno: number): Promise<{
        shards: {
            workchain: number;
            shard: string;
            seqno: number;
            transactions: {
                lt: string;
                hash: string;
                account: string;
            }[];
            fileHash: string;
            rootHash: string;
        }[];
    }>;
    /**
     * Get block info by unix timestamp
     * @param ts unix timestamp
     * @returns block info
     */
    getBlockByUtime(ts: number): Promise<{
        shards: {
            workchain: number;
            shard: string;
            seqno: number;
            transactions: {
                lt: string;
                hash: string;
                account: string;
            }[];
            fileHash: string;
            rootHash: string;
        }[];
    }>;
    /**
     * Get block info by unix timestamp
     * @param seqno block sequence number
     * @param address account address
     * @returns account info
     */
    getAccount(seqno: number, address: Address): Promise<{
        account: {
            balance: {
                coins: string;
            };
            state: {
                type: "uninit";
            } | {
                data: string | null;
                code: string | null;
                type: "active";
            } | {
                type: "frozen";
                stateHash: string;
            };
            last: {
                lt: string;
                hash: string;
            } | null;
            storageStat: {
                lastPaid: number;
                duePayment: string | null;
                used: {
                    bits: number;
                    cells: number;
                    publicCells: number;
                };
            } | null;
        };
        block: {
            workchain: number;
            shard: string;
            seqno: number;
            fileHash: string;
            rootHash: string;
        };
    }>;
    /**
     * Get account lite info (without code and data)
     * @param seqno block sequence number
     * @param address account address
     * @returns account lite info
     */
    getAccountLite(seqno: number, address: Address): Promise<{
        account: {
            balance: {
                coins: string;
            };
            state: {
                type: "uninit";
            } | {
                type: "active";
                codeHash: string;
                dataHash: string;
            } | {
                type: "frozen";
                stateHash: string;
            };
            last: {
                lt: string;
                hash: string;
            } | null;
            storageStat: {
                lastPaid: number;
                duePayment: string | null;
                used: {
                    bits: number;
                    cells: number;
                    publicCells: number;
                };
            } | null;
        };
    }>;
    /**
     * Check if contract is deployed
     * @param address addres to check
     * @returns true if contract is in active state
     */
    isContractDeployed(seqno: number, address: Address): Promise<boolean>;
    /**
     * Check if account was updated since
     * @param seqno block sequence number
     * @param address account address
     * @param lt account last transaction lt
     * @returns account change info
     */
    isAccountChanged(seqno: number, address: Address, lt: bigint): Promise<{
        block: {
            workchain: number;
            shard: string;
            seqno: number;
            fileHash: string;
            rootHash: string;
        };
        changed: boolean;
    }>;
    /**
     * Load unparsed account transactions
     * @param address address
     * @param lt last transaction lt
     * @param hash last transaction hash
     * @returns unparsed transactions
     */
    getAccountTransactions(address: Address, lt: bigint, hash: Buffer): Promise<{
        block: {
            workchain: number;
            seqno: number;
            shard: string;
            rootHash: string;
            fileHash: string;
        };
        tx: Transaction;
    }[]>;
    /**
     * Get network config
     * @param seqno block sequence number
     * @param ids optional config ids
     * @returns network config
     */
    getConfig(seqno: number, ids?: number[]): Promise<{
        config: {
            cell: string;
            address: string;
            globalBalance: {
                coins: string;
            };
        };
    }>;
    /**
     * Execute run method
     * @param seqno block sequence number
     * @param address account address
     * @param name method name
     * @param args method arguments
     * @returns method result
     */
    runMethod(seqno: number, address: Address, name: string, args?: TupleItem[]): Promise<{
        exitCode: number;
        result: TupleItem[];
        resultRaw: string | null;
        block: {
            workchain: number;
            shard: string;
            seqno: number;
            fileHash: string;
            rootHash: string;
        };
        shardBlock: {
            workchain: number;
            shard: string;
            seqno: number;
            fileHash: string;
            rootHash: string;
        };
        reader: TupleReader;
    }>;
    /**
     * Send external message
     * @param message message boc
     * @returns message status
     */
    sendMessage(message: Buffer): Promise<{
        status: any;
    }>;
    /**
     * Open smart contract
     * @param contract contract
     * @returns opened contract
     */
    open<T extends Contract>(contract: T): import("ton-core").OpenedContract<T>;
    /**
     * Open smart contract
     * @param block block number
     * @param contract contract
     * @returns opened contract
     */
    openAt<T extends Contract>(block: number, contract: T): import("ton-core").OpenedContract<T>;
    /**
     * Create provider
     * @param address address
     * @param init optional init data
     * @returns provider
     */
    provider(address: Address, init?: {
        code: Cell;
        data: Cell;
    } | null): ContractProvider;
    /**
     * Create provider at specified block number
     * @param block block number
     * @param address address
     * @param init optional init data
     * @returns provider
     */
    providerAt(block: number, address: Address, init?: {
        code: Cell;
        data: Cell;
    } | null): ContractProvider;
}
