"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _SendProviderSender_provider, _WrappedContractProvider_address, _WrappedContractProvider_provider, _WrappedContractProvider_init, _NetworkProviderImpl_tc, _NetworkProviderImpl_sender, _NetworkProviderImpl_network, _NetworkProviderImpl_explorer, _NetworkProviderImpl_ui;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNetworkProvider = void 0;
const utils_1 = require("../utils");
const arg_1 = __importDefault(require("arg"));
const DeeplinkProvider_1 = require("./send/DeeplinkProvider");
const TonConnectProvider_1 = require("./send/TonConnectProvider");
const TonHubProvider_1 = require("./send/TonHubProvider");
const ton_core_1 = require("ton-core");
const ton_1 = require("ton");
const ton_access_1 = require("@orbs-network/ton-access");
const FSStorage_1 = require("./storage/FSStorage");
const path_1 = __importDefault(require("path"));
const paths_1 = require("../paths");
const ton_crypto_1 = require("ton-crypto");
const MnemonicProvider_1 = require("./send/MnemonicProvider");
const argSpec = {
    '--mainnet': Boolean,
    '--testnet': Boolean,
    '--tonconnect': Boolean,
    '--deeplink': Boolean,
    '--tonhub': Boolean,
    '--mnemonic': Boolean,
    '--tonscan': Boolean,
    '--tonapi': Boolean,
    '--toncx': Boolean,
    '--dton': Boolean,
};
class SendProviderSender {
    constructor(provider) {
        _SendProviderSender_provider.set(this, void 0);
        __classPrivateFieldSet(this, _SendProviderSender_provider, provider, "f");
        this.address = provider.address();
    }
    async send(args) {
        if (args.bounce !== undefined) {
            console.warn("Warning: blueprint's Sender does not support `bounce` flag, because it is ignored by all used Sender APIs");
            console.warn('To silence this warning, change your `bounce` flags passed to Senders to unset or undefined');
        }
        if (!(args.sendMode === undefined || args.sendMode == ton_core_1.SendMode.PAY_GAS_SEPARATELY)) {
            throw new Error('Deployer sender does not support `sendMode` other than `PAY_GAS_SEPARATELY`');
        }
        await __classPrivateFieldGet(this, _SendProviderSender_provider, "f").sendTransaction(args.to, args.value, args.body ?? undefined, args.init ?? undefined);
    }
}
_SendProviderSender_provider = new WeakMap();
class WrappedContractProvider {
    constructor(address, provider, init) {
        _WrappedContractProvider_address.set(this, void 0);
        _WrappedContractProvider_provider.set(this, void 0);
        _WrappedContractProvider_init.set(this, void 0);
        __classPrivateFieldSet(this, _WrappedContractProvider_address, address, "f");
        __classPrivateFieldSet(this, _WrappedContractProvider_provider, provider, "f");
        __classPrivateFieldSet(this, _WrappedContractProvider_init, init, "f");
    }
    async getState() {
        return await __classPrivateFieldGet(this, _WrappedContractProvider_provider, "f").getState();
    }
    async get(name, args) {
        return await __classPrivateFieldGet(this, _WrappedContractProvider_provider, "f").get(name, args);
    }
    async external(message) {
        return await __classPrivateFieldGet(this, _WrappedContractProvider_provider, "f").external(message);
    }
    async internal(via, args) {
        const init = __classPrivateFieldGet(this, _WrappedContractProvider_init, "f") && (await this.getState()).state.type !== 'active' ? __classPrivateFieldGet(this, _WrappedContractProvider_init, "f") : undefined;
        return await via.send({
            to: __classPrivateFieldGet(this, _WrappedContractProvider_address, "f"),
            value: typeof args.value === 'string' ? (0, ton_core_1.toNano)(args.value) : args.value,
            sendMode: args.sendMode,
            bounce: args.bounce,
            init,
            body: typeof args.body === 'string' ? (0, ton_core_1.comment)(args.body) : args.body,
        });
    }
}
_WrappedContractProvider_address = new WeakMap(), _WrappedContractProvider_provider = new WeakMap(), _WrappedContractProvider_init = new WeakMap();
class NetworkProviderImpl {
    constructor(tc, sender, network, explorer, ui) {
        _NetworkProviderImpl_tc.set(this, void 0);
        _NetworkProviderImpl_sender.set(this, void 0);
        _NetworkProviderImpl_network.set(this, void 0);
        _NetworkProviderImpl_explorer.set(this, void 0);
        _NetworkProviderImpl_ui.set(this, void 0);
        __classPrivateFieldSet(this, _NetworkProviderImpl_tc, tc, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_sender, sender, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_network, network, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_explorer, explorer, "f");
        __classPrivateFieldSet(this, _NetworkProviderImpl_ui, ui, "f");
    }
    network() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_network, "f");
    }
    explorer() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_explorer, "f");
    }
    sender() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_sender, "f");
    }
    api() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f");
    }
    provider(address, init) {
        return new WrappedContractProvider(address, __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").provider(address, init ? { code: init.code ?? new ton_core_1.Cell(), data: init.data ?? new ton_core_1.Cell() } : undefined), init);
    }
    async isContractDeployed(address) {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").isContractDeployed((await __classPrivateFieldGet(this, _NetworkProviderImpl_tc, "f").getLastBlock()).last.seqno, address);
    }
    async waitForDeploy(address, attempts = 10, sleepDuration = 2000) {
        if (attempts <= 0) {
            throw new Error('Attempt number must be positive');
        }
        for (let i = 1; i <= attempts; i++) {
            __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").setActionPrompt(`Awaiting contract deployment... [Attempt ${i}/${attempts}]`);
            const isDeployed = await this.isContractDeployed(address);
            if (isDeployed) {
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").clearActionPrompt();
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").write(`Contract deployed at address ${address.toString()}`);
                __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").write(`You can view it at ${(0, utils_1.getExplorerLink)(address.toString(), __classPrivateFieldGet(this, _NetworkProviderImpl_network, "f"), __classPrivateFieldGet(this, _NetworkProviderImpl_explorer, "f"))}`);
                return;
            }
            await (0, utils_1.sleep)(sleepDuration);
        }
        __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f").clearActionPrompt();
        throw new Error("Contract was not deployed. Check your wallet's transactions");
    }
    /**
     * @deprecated
     *
     * Use your Contract's `sendDeploy` method (or similar) together with `waitForDeploy` instead.
     */
    async deploy(contract, value, body, waitAttempts = 10) {
        const isDeployed = await this.isContractDeployed(contract.address);
        if (isDeployed) {
            throw new Error('Contract is already deployed!');
        }
        if (!contract.init) {
            throw new Error('Contract has no init!');
        }
        await __classPrivateFieldGet(this, _NetworkProviderImpl_sender, "f").send({
            to: contract.address,
            value,
            body,
            init: contract.init,
        });
        if (waitAttempts <= 0)
            return;
        await this.waitForDeploy(contract.address, waitAttempts);
    }
    open(contract) {
        return (0, ton_core_1.openContract)(contract, (params) => this.provider(params.address, params.init ?? undefined));
    }
    ui() {
        return __classPrivateFieldGet(this, _NetworkProviderImpl_ui, "f");
    }
}
_NetworkProviderImpl_tc = new WeakMap(), _NetworkProviderImpl_sender = new WeakMap(), _NetworkProviderImpl_network = new WeakMap(), _NetworkProviderImpl_explorer = new WeakMap(), _NetworkProviderImpl_ui = new WeakMap();
async function createMnemonicProvider(client, ui) {
    const mnemonic = process.env.WALLET_MNEMONIC ?? '';
    const walletVersion = process.env.WALLET_VERSION ?? '';
    if (mnemonic.length === 0 || walletVersion.length === 0) {
        throw new Error('Mnemonic deployer was chosen, but env variables WALLET_MNEMONIC and WALLET_VERSION are not set');
    }
    const keyPair = await (0, ton_crypto_1.mnemonicToPrivateKey)(mnemonic.split(' '));
    return new MnemonicProvider_1.MnemonicProvider({
        version: walletVersion.toLowerCase(),
        client,
        secretKey: keyPair.secretKey,
        ui,
    });
}
class NetworkProviderBuilder {
    constructor(args, ui) {
        this.args = args;
        this.ui = ui;
    }
    async chooseNetwork() {
        let network = (0, utils_1.oneOrZeroOf)({
            mainnet: this.args['--mainnet'],
            testnet: this.args['--testnet'],
        });
        if (!network) {
            network = await this.ui.choose('Which network do you want to use?', ['mainnet', 'testnet'], (c) => c);
        }
        return network;
    }
    chooseExplorer() {
        return ((0, utils_1.oneOrZeroOf)({
            tonscan: this.args['--tonscan'],
            tonapi: this.args['--tonapi'],
            toncx: this.args['--toncx'],
            dton: this.args['--dton'],
        }) ?? 'tonscan');
    }
    async chooseSendProvider(network, client) {
        let deployUsing = (0, utils_1.oneOrZeroOf)({
            tonconnect: this.args['--tonconnect'],
            deeplink: this.args['--deeplink'],
            tonhub: this.args['--tonhub'],
            mnemonic: this.args['--mnemonic'],
        });
        if (!deployUsing) {
            deployUsing = (await this.ui.choose('Which wallet are you using?', [
                {
                    name: 'TON Connect compatible mobile wallet (example: Tonkeeper)',
                    value: 'tonconnect',
                },
                {
                    name: 'Create a ton:// deep link',
                    value: 'deeplink',
                },
                {
                    name: 'Tonhub wallet',
                    value: 'tonhub',
                },
                {
                    name: 'Mnemonic',
                    value: 'mnemonic',
                },
            ], (c) => c.name)).value;
        }
        const storagePath = path_1.default.join(paths_1.TEMP_DIR, network, deployUsing + '.json');
        let provider;
        switch (deployUsing) {
            case 'deeplink':
                provider = new DeeplinkProvider_1.DeeplinkProvider(this.ui);
                break;
            case 'tonconnect':
                provider = new TonConnectProvider_1.TonConnectProvider(new FSStorage_1.FSStorage(storagePath), this.ui);
                break;
            case 'tonhub':
                provider = new TonHubProvider_1.TonHubProvider(network, new FSStorage_1.FSStorage(storagePath), this.ui);
                break;
            case 'mnemonic':
                provider = await createMnemonicProvider(client, this.ui);
                break;
            default:
                throw new Error('Unknown deploy option');
        }
        return provider;
    }
    async build() {
        const network = await this.chooseNetwork();
        const explorer = this.chooseExplorer();
        const tc = new ton_1.TonClient4({
            endpoint: await (0, ton_access_1.getHttpV4Endpoint)({ network }),
        });
        const sendProvider = await this.chooseSendProvider(network, tc);
        try {
            await sendProvider.connect();
        }
        catch (e) {
            console.error('Unable to connect to wallet.');
            process.exit(1);
        }
        finally {
            this.ui.setActionPrompt('');
        }
        const sender = new SendProviderSender(sendProvider);
        return new NetworkProviderImpl(tc, sender, network, explorer, this.ui);
    }
}
async function createNetworkProvider(ui) {
    const args = (0, arg_1.default)(argSpec);
    return await new NetworkProviderBuilder(args, ui).build();
}
exports.createNetworkProvider = createNetworkProvider;
