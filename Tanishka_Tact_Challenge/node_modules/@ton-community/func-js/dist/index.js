"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.compileFunc = exports.compilerVersion = exports.latestCompiler = exports.FuncCompiler = exports.sourcesResolver = exports.arraySourceResolver = exports.mapSourceResolver = void 0;
const path_1 = require("./path");
const utils_1 = require("./utils");
const func_js_bin_1 = require("@ton-community/func-js-bin");
const mapSourceResolver = (map) => {
    return (path) => {
        if (path in map) {
            return map[path];
        }
        throw new Error(`Cannot find source file \`${path}\``);
    };
};
exports.mapSourceResolver = mapSourceResolver;
const arraySourceResolver = (arr) => {
    return (path) => {
        const entry = arr.find(e => e.filename === path);
        if (entry === undefined)
            throw new Error(`Cannot find source file \`${path}\``);
        return entry.content;
    };
};
exports.arraySourceResolver = arraySourceResolver;
const sourcesResolver = (sources) => {
    if (typeof sources === 'function')
        return sources;
    if (Array.isArray(sources))
        return (0, exports.arraySourceResolver)(sources);
    return (0, exports.mapSourceResolver)(sources);
};
exports.sourcesResolver = sourcesResolver;
const copyToCString = (mod, str) => {
    const len = mod.lengthBytesUTF8(str) + 1;
    const ptr = mod._malloc(len);
    mod.stringToUTF8(str, ptr, len);
    return ptr;
};
const copyToCStringPtr = (mod, str, ptr) => {
    const allocated = copyToCString(mod, str);
    mod.setValue(ptr, allocated, '*');
    return allocated;
};
const copyFromCString = (mod, ptr) => {
    return mod.UTF8ToString(ptr);
};
class FuncCompiler {
    constructor(funcWASMObject) {
        this.createModule = async () => await this.module({ wasmBinary: this.wasmBinary });
        this.compilerVersion = async () => {
            const mod = await this.createModule();
            const versionJsonPointer = mod._version();
            const versionJson = copyFromCString(mod, versionJsonPointer);
            mod._free(versionJsonPointer);
            return JSON.parse(versionJson);
        };
        this.validateVersion = async () => {
            const v = await this.compilerVersion();
            return v.funcVersion === this.inputFuncVersion;
        };
        this.compileFunc = async (compileConfig) => {
            const resolver = (0, exports.sourcesResolver)(compileConfig.sources);
            let targets = compileConfig.targets;
            if (targets === undefined && Array.isArray(compileConfig.sources)) {
                targets = compileConfig.sources.map(s => s.filename);
            }
            if (targets === undefined) {
                throw new Error('`sources` is not an array and `targets` were not provided');
            }
            const entryWithNoSource = targets.find(filename => {
                try {
                    resolver(filename);
                    return false;
                }
                catch (e) {
                    return true;
                }
            });
            if (entryWithNoSource) {
                throw new Error(`The entry point \`${entryWithNoSource}\` was not provided in sources.`);
            }
            const mod = await this.createModule();
            const allocatedPointers = [];
            const sourceMap = {};
            const sourceOrder = [];
            const callbackPtr = mod.addFunction((_kind, _data, contents, error) => {
                const kind = copyFromCString(mod, _kind);
                const data = copyFromCString(mod, _data);
                if (kind === 'realpath') {
                    const path = (0, path_1.normalize)(data);
                    allocatedPointers.push(copyToCStringPtr(mod, path, contents));
                }
                else if (kind === 'source') {
                    const path = (0, path_1.normalize)(data);
                    try {
                        const source = resolver(path);
                        sourceMap[path] = { content: source, included: false };
                        sourceOrder.push(path);
                        allocatedPointers.push(copyToCStringPtr(mod, source, contents));
                    }
                    catch (err) {
                        const e = err;
                        allocatedPointers.push(copyToCStringPtr(mod, 'message' in e ? e.message : e.toString(), error));
                    }
                }
                else {
                    allocatedPointers.push(copyToCStringPtr(mod, 'Unknown callback kind ' + kind, error));
                }
            }, 'viiii');
            const configStr = JSON.stringify({
                sources: targets,
                optLevel: compileConfig.optLevel || 2,
            });
            const configStrPointer = copyToCString(mod, configStr);
            allocatedPointers.push(configStrPointer);
            const resultPointer = mod._func_compile(configStrPointer, callbackPtr);
            allocatedPointers.push(resultPointer);
            const retJson = copyFromCString(mod, resultPointer);
            // Cleanup
            allocatedPointers.forEach(ptr => mod._free(ptr));
            mod.removeFunction(callbackPtr);
            const snapshot = [];
            for (let i = sourceOrder.length - 1; i >= 0; i--) {
                const path = sourceOrder[i];
                if (sourceMap[path].included)
                    continue;
                snapshot.push({
                    filename: path,
                    content: sourceMap[path].content,
                });
            }
            const ret = JSON.parse(retJson);
            return {
                ...ret,
                snapshot,
            };
        };
        if (!('schemaVersion' in funcWASMObject))
            throw new Error('FunC WASM Object does not contain schemaVersion');
        if (funcWASMObject.schemaVersion !== 1)
            throw new Error('FunC WASM Object is of unknown schemaVersion ' + funcWASMObject.schemaVersion);
        const normalObject = funcWASMObject;
        this.module = normalObject.module;
        this.wasmBinary = (0, utils_1.base64Decode)(normalObject.wasmBase64);
        this.inputFuncVersion = normalObject.funcVersion;
    }
}
exports.FuncCompiler = FuncCompiler;
exports.latestCompiler = new FuncCompiler(func_js_bin_1.object);
exports.compilerVersion = exports.latestCompiler.compilerVersion;
exports.compileFunc = exports.latestCompiler.compileFunc;
