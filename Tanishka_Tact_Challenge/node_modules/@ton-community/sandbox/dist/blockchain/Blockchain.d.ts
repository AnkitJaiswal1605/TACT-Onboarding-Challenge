import { Address, Cell, Message, Transaction, ContractProvider, Contract, Sender, ShardAccount, TupleItem, ExternalAddress, StateInit } from "ton-core";
import { Executor, TickOrTock } from "../executor/Executor";
import { BlockchainStorage } from "./BlockchainStorage";
import { Event } from "../event/Event";
import { SandboxContractProvider } from "./BlockchainContractProvider";
import { TreasuryContract } from "../treasury/Treasury";
import { GetMethodParams, LogsVerbosity, MessageParams, SmartContract, SmartContractSnapshot, Verbosity } from "./SmartContract";
import { AsyncLock } from "../utils/AsyncLock";
export type ExternalOutInfo = {
    type: 'external-out';
    src: Address;
    dest?: ExternalAddress;
    createdAt: number;
    createdLt: bigint;
};
export type ExternalOut = {
    info: ExternalOutInfo;
    init?: StateInit;
    body: Cell;
};
export type BlockchainTransaction = Transaction & {
    blockchainLogs: string;
    vmLogs: string;
    debugLogs: string;
    events: Event[];
    parent?: BlockchainTransaction;
    children: BlockchainTransaction[];
    externals: ExternalOut[];
};
export type SendMessageResult = {
    transactions: BlockchainTransaction[];
    events: Event[];
    externals: ExternalOut[];
};
type ExtendsContractProvider<T> = T extends ContractProvider ? true : (T extends SandboxContractProvider ? true : false);
export type SandboxContract<F> = {
    [P in keyof F]: P extends `get${string}` ? (F[P] extends (x: infer CP, ...args: infer P) => infer R ? (ExtendsContractProvider<CP> extends true ? (...args: P) => R : never) : never) : (P extends `send${string}` ? (F[P] extends (x: infer CP, ...args: infer P) => infer R ? (ExtendsContractProvider<CP> extends true ? (...args: P) => Promise<SendMessageResult & {
        result: R extends Promise<infer PR> ? PR : R;
    }> : never) : never) : F[P]);
};
export type PendingMessage = (({
    type: 'message';
} & Message) | ({
    type: 'ticktock';
    which: TickOrTock;
    on: Address;
})) & {
    parentTransaction?: BlockchainTransaction;
};
export type TreasuryParams = Partial<{
    workchain: number;
    predeploy: boolean;
    balance: bigint;
    resetBalanceIfZero: boolean;
}>;
export type BlockchainConfig = Cell | 'default' | 'slim';
export type BlockchainSnapshot = {
    contracts: SmartContractSnapshot[];
    networkConfig: string;
    lt: bigint;
    time?: number;
    verbosity: LogsVerbosity;
    libs?: Cell;
    nextCreateWalletIndex: number;
};
export declare class Blockchain {
    protected storage: BlockchainStorage;
    protected networkConfig: string;
    protected currentLt: bigint;
    protected currentTime?: number;
    protected messageQueue: PendingMessage[];
    protected logsVerbosity: LogsVerbosity;
    protected globalLibs?: Cell;
    protected lock: AsyncLock;
    protected contractFetches: Map<string, Promise<SmartContract>>;
    protected nextCreateWalletIndex: number;
    readonly executor: Executor;
    snapshot(): BlockchainSnapshot;
    loadFrom(snapshot: BlockchainSnapshot): Promise<void>;
    get now(): number | undefined;
    set now(now: number | undefined);
    get lt(): bigint;
    protected constructor(opts: {
        executor: Executor;
        config?: BlockchainConfig;
        storage: BlockchainStorage;
    });
    get config(): Cell;
    get configBase64(): string;
    sendMessage(message: Message | Cell, params?: MessageParams): Promise<SendMessageResult>;
    runTickTock(on: Address | Address[], which: TickOrTock, params?: MessageParams): Promise<SendMessageResult>;
    runGetMethod(address: Address, method: number | string, stack?: TupleItem[], params?: GetMethodParams): Promise<import("./SmartContract").GetMethodResult>;
    protected pushMessage(message: Message | Cell): Promise<void>;
    protected pushTickTock(on: Address, which: TickOrTock): Promise<void>;
    protected runQueue(params?: MessageParams): Promise<SendMessageResult>;
    protected processQueue(params?: MessageParams): Promise<BlockchainTransaction[]>;
    provider(address: Address, init?: {
        code: Cell;
        data: Cell;
    }): ContractProvider;
    sender(address: Address): Sender;
    protected treasuryParamsToMapKey(workchain: number, seed: string): string;
    treasury(seed: string, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>>;
    createWallets(n: number, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>[]>;
    openContract<T extends Contract>(contract: T): SandboxContract<T>;
    protected startFetchingContract(address: Address): Promise<SmartContract>;
    getContract(address: Address): Promise<SmartContract>;
    get verbosity(): LogsVerbosity;
    set verbosity(value: LogsVerbosity);
    setVerbosityForAddress(address: Address, verbosity: Partial<LogsVerbosity> | Verbosity | undefined): Promise<void>;
    setConfig(config: BlockchainConfig): void;
    setShardAccount(address: Address, account: ShardAccount): Promise<void>;
    get libs(): Cell | undefined;
    set libs(value: Cell | undefined);
    static create(opts?: {
        config?: BlockchainConfig;
        storage?: BlockchainStorage;
    }): Promise<Blockchain>;
}
export {};
