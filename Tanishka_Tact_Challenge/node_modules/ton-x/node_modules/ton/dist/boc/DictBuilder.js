"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.beginDict = exports.DictBuilder = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const Builder_1 = require("./Builder");
const serializeDict_1 = require("./dict/serializeDict");
class DictBuilder {
    constructor(keySize) {
        this.items = new Map();
        this.ended = false;
        this.storeCell = (index, value) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            let key;
            if (typeof index === 'number') {
                key = index.toString(10);
            }
            else if (bn_js_1.default.isBN(index)) {
                key = index.toString(10);
            }
            else if (Buffer.isBuffer(index)) {
                key = new bn_js_1.default(index.toString('hex'), 'hex').toString(10);
            }
            else {
                throw Error('Invalid index type');
            }
            if (this.items.has(key)) {
                throw Error('Item ' + index + ' already exist');
            }
            this.items.set(key, value);
        };
        this.storeRef = (index, value) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.storeCell(index, (0, Builder_1.beginCell)()
                .storeRef(value)
                .endCell());
        };
        this.endDict = () => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.ended = true;
            if (this.items.size === 0) {
                return null;
            }
            return (0, serializeDict_1.serializeDict)(this.items, this.keySize, (src, dst) => dst.writeCell(src));
        };
        this.endCell = () => {
            if (this.ended) {
                throw Error('Already ended');
            }
            if (this.items.size === 0) {
                throw Error('Dict is empty');
            }
            return this.endDict();
        };
        this.keySize = keySize;
    }
}
exports.DictBuilder = DictBuilder;
function beginDict(keyLength) {
    return new DictBuilder(keyLength);
}
exports.beginDict = beginDict;
