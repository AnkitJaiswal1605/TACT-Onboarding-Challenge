"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _BitString_instances, _BitString_length, _BitString_cursor, _BitString_buffer, _BitString_checkRange, _a, _b;
Object.defineProperty(exports, "__esModule", { value: true });
exports.BitString = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const symbol_inspect_1 = __importDefault(require("symbol.inspect"));
const __1 = require("..");
class BitString {
    constructor(buffer, length, cursor) {
        _BitString_instances.add(this);
        _BitString_length.set(this, void 0);
        _BitString_cursor.set(this, void 0);
        _BitString_buffer.set(this, void 0);
        this[_a] = () => {
            let offset = 0;
            let end = __classPrivateFieldGet(this, _BitString_cursor, "f");
            return {
                next: () => {
                    if (offset < end) {
                        let v = this.get(offset);
                        offset++;
                        return {
                            done: false,
                            value: v
                        };
                    }
                    else {
                        return {
                            done: true
                        };
                    }
                }
            };
        };
        this.get = (n) => {
            __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
            return (__classPrivateFieldGet(this, _BitString_buffer, "f")[(n / 8) | 0] & (1 << (7 - (n % 8)))) > 0;
        };
        this.on = (n) => {
            __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
            __classPrivateFieldGet(this, _BitString_buffer, "f")[(n / 8) | 0] |= 1 << (7 - (n % 8));
        };
        this.off = (n) => {
            __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
            __classPrivateFieldGet(this, _BitString_buffer, "f")[(n / 8) | 0] &= ~(1 << (7 - (n % 8)));
        };
        this.toggle = (n) => {
            __classPrivateFieldGet(this, _BitString_instances, "m", _BitString_checkRange).call(this, n);
            __classPrivateFieldGet(this, _BitString_buffer, "f")[(n / 8) | 0] ^= 1 << (7 - (n % 8));
        };
        this.writeBit = (value) => {
            var _c;
            if (value === true || value > 0) {
                this.on(__classPrivateFieldGet(this, _BitString_cursor, "f"));
            }
            else {
                this.off(__classPrivateFieldGet(this, _BitString_cursor, "f"));
            }
            __classPrivateFieldSet(this, _BitString_cursor, (_c = __classPrivateFieldGet(this, _BitString_cursor, "f"), _c++, _c), "f");
        };
        this.writeUint = (value, bitLength) => {
            let v = new bn_js_1.default(value);
            if (bitLength == 0 || (value.toString(2).length > bitLength)) {
                if (v.isZero()) {
                    return;
                }
                throw Error(`bitLength is too small for a value ${v.toString()}. Got ${bitLength}, expected >= ${value.toString(2).length}`);
            }
            const s = v.toString(2, bitLength);
            for (let i = 0; i < bitLength; i++) {
                this.writeBit(s[i] === '1');
            }
        };
        this.writeInt = (value, bitLength) => {
            let v = new bn_js_1.default(value);
            if (bitLength == 1) {
                if (v.eq(new bn_js_1.default(-1))) {
                    this.writeBit(true);
                    return;
                }
                if (v.isZero()) {
                    this.writeBit(false);
                    return;
                }
                throw Error(`bitlength is too small for a value ${v}`);
            }
            else {
                if (v.isNeg()) {
                    this.writeBit(true);
                    const b = new bn_js_1.default(2);
                    const nb = b.pow(new bn_js_1.default(bitLength - 1));
                    this.writeUint(nb.add(v), bitLength - 1);
                }
                else {
                    this.writeBit(false);
                    this.writeUint(v, bitLength - 1);
                }
            }
        };
        this.writeUint8 = (value) => {
            this.writeUint(value, 8);
        };
        this.writeBuffer = (buffer) => {
            for (let i = 0; i < buffer.length; i++) {
                this.writeUint8(buffer[i]);
            }
        };
        this.writeCoins = (amount) => {
            if (amount == 0) {
                this.writeUint(0, 4);
            }
            else {
                amount = new bn_js_1.default(amount);
                const l = Math.ceil((amount.toString(16).length) / 2);
                this.writeUint(l, 4);
                this.writeUint(amount, l * 8);
            }
        };
        this.writeAddress = (address) => {
            if (address === null) {
                this.writeUint(0, 2);
            }
            else {
                this.writeUint(2, 2);
                this.writeUint(0, 1);
                this.writeInt(address.workChain, 8);
                this.writeBuffer(address.hash);
            }
        };
        this.writeBitString = (value) => {
            for (let v of value) {
                this.writeBit(v);
            }
        };
        this[_b] = () => this.toFiftHex();
        __classPrivateFieldSet(this, _BitString_buffer, buffer, "f");
        __classPrivateFieldSet(this, _BitString_length, length, "f");
        __classPrivateFieldSet(this, _BitString_cursor, cursor, "f");
    }
    static alloc(length) {
        return new BitString(Buffer.alloc(Math.ceil(length / 8), 0), length, 0);
    }
    get available() {
        return this.length - this.cursor;
    }
    get length() {
        return __classPrivateFieldGet(this, _BitString_length, "f");
    }
    get cursor() {
        return __classPrivateFieldGet(this, _BitString_cursor, "f");
    }
    get buffer() {
        return __classPrivateFieldGet(this, _BitString_buffer, "f");
    }
    writeBitArray(value) {
        for (let v of value) {
            this.writeBit(v);
        }
    }
    clone() {
        let buf = Buffer.alloc(__classPrivateFieldGet(this, _BitString_buffer, "f").length);
        __classPrivateFieldGet(this, _BitString_buffer, "f").copy(buf);
        return new BitString(buf, __classPrivateFieldGet(this, _BitString_length, "f"), __classPrivateFieldGet(this, _BitString_cursor, "f"));
    }
    toString() {
        let res = '';
        for (let v of this) {
            if (v) {
                res = res + '1';
            }
            else {
                res = res + '0';
            }
        }
        return res;
    }
    toFiftHex() {
        if (this.cursor % 4 === 0) {
            const s = __classPrivateFieldGet(this, _BitString_buffer, "f").slice(0, Math.ceil(this.cursor / 8)).toString('hex').toUpperCase();
            if (this.cursor % 8 === 0) {
                return s;
            }
            else {
                return s.substr(0, s.length - 1);
            }
        }
        else {
            const temp = this.clone();
            temp.writeBit(1);
            while (temp.cursor % 4 !== 0) {
                temp.writeBit(0);
            }
            const hex = temp.toFiftHex().toUpperCase();
            return hex + '_';
        }
    }
    setTopUppedArray(array, fullfilledBytes = true) {
        __classPrivateFieldSet(this, _BitString_length, array.length * 8, "f");
        __classPrivateFieldSet(this, _BitString_buffer, Buffer.alloc(array.length), "f");
        array.copy(__classPrivateFieldGet(this, _BitString_buffer, "f"));
        __classPrivateFieldSet(this, _BitString_cursor, this.length, "f");
        if (fullfilledBytes || !this.length) {
            return;
        }
        else {
            let foundEndBit = false;
            for (let c = 0; c < 7; c++) {
                __classPrivateFieldSet(this, _BitString_cursor, __classPrivateFieldGet(this, _BitString_cursor, "f") - 1, "f");
                if (this.get(this.cursor)) {
                    foundEndBit = true;
                    this.off(this.cursor);
                    break;
                }
            }
            if (!foundEndBit) {
                throw new Error("Incorrect TopUppedArray");
            }
        }
    }
    getTopUppedArray() {
        const ret = this.clone();
        let tu = Math.ceil(ret.cursor / 8) * 8 - ret.cursor;
        if (tu > 0) {
            tu = tu - 1;
            ret.writeBit(true);
            while (tu > 0) {
                tu = tu - 1;
                ret.writeBit(false);
            }
        }
        __classPrivateFieldSet(ret, _BitString_buffer, __classPrivateFieldGet(ret, _BitString_buffer, "f").slice(0, Math.ceil(ret.cursor / 8)), "f");
        return __classPrivateFieldGet(ret, _BitString_buffer, "f");
    }
    equals(src) {
        if (src.cursor !== this.cursor) {
            return false;
        }
        if (src.length !== this.length) {
            return false;
        }
        let sr = new __1.BitStringReader(src);
        let tr = new __1.BitStringReader(this);
        for (let i = 0; i < src.cursor; i++) {
            if (sr.readBit() !== tr.readBit()) {
                return false;
            }
        }
        return true;
    }
}
exports.BitString = BitString;
_BitString_length = new WeakMap(), _BitString_cursor = new WeakMap(), _BitString_buffer = new WeakMap(), _BitString_instances = new WeakSet(), _a = Symbol.iterator, _b = symbol_inspect_1.default, _BitString_checkRange = function _BitString_checkRange(n) {
    if (n > this.length) {
        throw Error('Invalid index: ' + n);
    }
};
