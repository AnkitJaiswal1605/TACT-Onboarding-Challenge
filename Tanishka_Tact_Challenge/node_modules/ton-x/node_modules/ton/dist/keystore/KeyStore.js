"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _KeyStore_salt, _KeyStore_publicKey, _KeyStore_records;
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeyStore = exports.createKeyStoreKey = void 0;
const ton_crypto_1 = require("ton-crypto");
const t = __importStar(require("io-ts"));
const Either_1 = require("fp-ts/lib/Either");
const __1 = require("..");
const tweetnacl_1 = __importDefault(require("tweetnacl"));
const codec = t.type({
    version: t.number,
    salt: t.string,
    publicKey: t.string,
    records: t.array(t.type({
        name: t.string,
        address: t.string,
        kind: t.string,
        config: t.string,
        publicKey: t.string,
        secretKey: t.string,
        comment: t.string
    }))
});
async function createKeyStoreKey(password, salt) {
    let secretKey = await (0, ton_crypto_1.pbkdf2_sha512)(password, salt, 400000, 32);
    let r = tweetnacl_1.default.box.keyPair.fromSecretKey(secretKey);
    return {
        secretKey: Buffer.from(r.secretKey),
        publicKey: Buffer.from(r.publicKey)
    };
}
exports.createKeyStoreKey = createKeyStoreKey;
class KeyStore {
    constructor(src) {
        _KeyStore_salt.set(this, void 0);
        _KeyStore_publicKey.set(this, void 0);
        _KeyStore_records.set(this, new Map());
        this.checkPassword = async (password) => {
            let key = await createKeyStoreKey(password, Buffer.from(__classPrivateFieldGet(this, _KeyStore_salt, "f"), 'hex'));
            if (!key.publicKey.equals(Buffer.from(__classPrivateFieldGet(this, _KeyStore_publicKey, "f"), 'hex'))) {
                return false;
            }
            else {
                return true;
            }
        };
        this.hasKey = (name) => {
            return __classPrivateFieldGet(this, _KeyStore_records, "f").has(name);
        };
        this.getKey = (name) => {
            let ex = __classPrivateFieldGet(this, _KeyStore_records, "f").get(name);
            if (ex) {
                return {
                    name: ex.name,
                    address: ex.address,
                    kind: ex.kind,
                    config: ex.config,
                    comment: ex.comment,
                    publicKey: Buffer.from(ex.publicKey, 'hex')
                };
            }
            return null;
        };
        this.getSecret = async (name, password) => {
            if (!__classPrivateFieldGet(this, _KeyStore_records, "f").has(name)) {
                throw Error('Key with name ' + name + ' does not exist');
            }
            let record = __classPrivateFieldGet(this, _KeyStore_records, "f").get(name);
            let src = Buffer.from(record.secretKey, 'hex');
            let nonce = src.slice(0, 24);
            let publicKey = src.slice(24, 24 + 32);
            let data = src.slice(24 + 32);
            // Derive key
            let key = await createKeyStoreKey(password, Buffer.from(__classPrivateFieldGet(this, _KeyStore_salt, "f"), 'hex'));
            if (!key.publicKey.equals(Buffer.from(__classPrivateFieldGet(this, _KeyStore_publicKey, "f"), 'hex'))) {
                throw Error('Invalid password');
            }
            // Decode
            let decoded = tweetnacl_1.default.box.open(data, nonce, publicKey, key.secretKey);
            if (!decoded) {
                throw Error('Invalid password');
            }
            return Buffer.from(decoded);
        };
        this.addKey = async (record, key) => {
            if (__classPrivateFieldGet(this, _KeyStore_records, "f").has(record.name)) {
                throw Error('Key with name ' + record.name + ' already exists');
            }
            // Create key
            let ephemeralKeySecret = await (0, ton_crypto_1.getSecureRandomBytes)(32);
            let ephemeralKeyPublic = Buffer.from((tweetnacl_1.default.box.keyPair.fromSecretKey(ephemeralKeySecret)).publicKey);
            let nonce = await (0, ton_crypto_1.getSecureRandomBytes)(24);
            let encrypted = tweetnacl_1.default.box(key, nonce, Buffer.from(__classPrivateFieldGet(this, _KeyStore_publicKey, "f"), 'hex'), ephemeralKeySecret);
            let data = Buffer.concat([nonce, ephemeralKeyPublic, encrypted]);
            // Create record
            let rec = {
                name: record.name,
                address: record.address,
                kind: record.kind,
                config: record.config,
                comment: record.comment,
                publicKey: record.publicKey.toString('hex'),
                secretKey: data.toString('hex')
            };
            Object.freeze(rec);
            __classPrivateFieldGet(this, _KeyStore_records, "f").set(record.name, rec);
        };
        this.removeKey = (name) => {
            if (!__classPrivateFieldGet(this, _KeyStore_records, "f").has(name)) {
                throw Error('Key with name ' + name + ' does not exist');
            }
            __classPrivateFieldGet(this, _KeyStore_records, "f").delete(name);
        };
        if (src.version !== 1) {
            throw Error('Unsupported keystore');
        }
        __classPrivateFieldSet(this, _KeyStore_salt, src.salt, "f");
        __classPrivateFieldSet(this, _KeyStore_publicKey, src.publicKey, "f");
        for (let r of src.records) {
            if (__classPrivateFieldGet(this, _KeyStore_records, "f").has(r.name)) {
                throw Error('Broken keystore');
            }
            const record = {
                name: r.name,
                address: __1.Address.parseRaw(r.address),
                kind: r.kind,
                config: r.config,
                comment: r.comment,
                publicKey: r.publicKey,
                secretKey: r.secretKey
            };
            Object.freeze(record);
            __classPrivateFieldGet(this, _KeyStore_records, "f").set(r.name, record);
        }
    }
    static async createNew(password) {
        let salt = await (0, ton_crypto_1.getSecureRandomBytes)(32);
        let key = await createKeyStoreKey(password, salt);
        return new KeyStore({ version: 1, salt: salt.toString('hex'), publicKey: key.publicKey.toString('hex'), records: [] });
    }
    static async load(source) {
        // Validate checksum
        if (source.length < 32) {
            throw Error('Broken keystore');
        }
        let hash = source.slice(0, 32);
        let data = source.slice(32);
        let hash2 = await (0, ton_crypto_1.sha256)(data);
        if (!hash.equals(hash2)) { // We don't care about timing attacks here
            throw Error('Broken keystore');
        }
        // Parse storage
        let parsed = JSON.parse(data.toString('utf-8'));
        let decoded = codec.decode(parsed);
        if ((0, Either_1.isLeft)(decoded)) {
            throw Error('Broken keystore');
        }
        return new KeyStore(decoded.right);
    }
    get allKeys() {
        let res = [];
        for (let k of __classPrivateFieldGet(this, _KeyStore_records, "f").keys()) {
            let r = __classPrivateFieldGet(this, _KeyStore_records, "f").get(k);
            res.push({
                name: r.name,
                address: r.address,
                kind: r.kind,
                config: r.config,
                comment: r.comment,
                publicKey: Buffer.from(r.publicKey, 'hex')
            });
        }
        return res;
    }
    async save() {
        let store = {
            version: 1,
            salt: __classPrivateFieldGet(this, _KeyStore_salt, "f"),
            publicKey: __classPrivateFieldGet(this, _KeyStore_publicKey, "f"),
            records: Array.from(__classPrivateFieldGet(this, _KeyStore_records, "f").entries()).map((v) => ({
                name: v[1].name,
                address: v[1].address.toString(),
                kind: v[1].kind,
                config: v[1].config,
                comment: v[1].comment,
                publicKey: v[1].publicKey,
                secretKey: v[1].secretKey
            }))
        };
        let data = Buffer.from(JSON.stringify(store), 'utf-8');
        let hash = await (0, ton_crypto_1.sha256)(data);
        return Buffer.concat([hash, data]);
    }
}
exports.KeyStore = KeyStore;
_KeyStore_salt = new WeakMap(), _KeyStore_publicKey = new WeakMap(), _KeyStore_records = new WeakMap();
