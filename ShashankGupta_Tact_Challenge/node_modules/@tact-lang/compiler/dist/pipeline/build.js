"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const ton_core_1 = require("ton-core");
const opcode_1 = require("@tact-lang/opcode");
const writeTypescript_1 = require("../bindings/writeTypescript");
const features_1 = require("../config/features");
const context_1 = require("../context");
const funcCompile_1 = require("../func/funcCompile");
const writeReport_1 = require("../generator/writeReport");
const store_1 = require("../grammar/store");
const stdlib_1 = __importDefault(require("../imports/stdlib"));
const logger_1 = require("../logger");
const packageCode_1 = require("../packaging/packageCode");
const resolveABITypeRef_1 = require("../types/resolveABITypeRef");
const resolveDescriptors_1 = require("../types/resolveDescriptors");
const errorToString_1 = require("../utils/errorToString");
const createVirtualFileSystem_1 = require("../vfs/createVirtualFileSystem");
const compile_1 = require("./compile");
const precompile_1 = require("./precompile");
const version_1 = require("./version");
// ts-ignore is used on purpose here (instead of installing @types/node or similar)
// because the whole package must not depend on any node code
// however, this function is required to fix compilation on windows
function posixNormalize(path) {
    // @ts-ignore
    if (typeof global === 'object' && typeof global.process === 'object' && typeof global.process.versions === 'object' && global.process.versions.node) {
        // @ts-ignore
        const pathModule = require('node:path');
        return path.split(pathModule.sep).join(pathModule.posix.sep);
    }
    return path;
}
async function build(args) {
    const { config, project } = args;
    const stdlib = (typeof args.stdlib === 'string') ? (0, createVirtualFileSystem_1.createVirtualFileSystem)(args.stdlib, stdlib_1.default) : args.stdlib;
    const logger = args.logger || logger_1.consoleLogger;
    // Configure context
    let ctx = new context_1.CompilerContext({ shared: {} });
    let cfg = JSON.stringify({
        entrypoint: config.path,
        options: (config.options || {})
    });
    if (config.options) {
        if (config.options.debug) {
            logger.error('   > ðŸ‘€ Enabling debug');
            ctx = (0, features_1.featureEnable)(ctx, 'debug');
        }
        if (config.options.masterchain) {
            logger.error('   > ðŸ‘€ Enabling masterchain');
            ctx = (0, features_1.featureEnable)(ctx, 'masterchain');
        }
        if (config.options.external) {
            logger.error('   > ðŸ‘€ Enabling external');
            ctx = (0, features_1.featureEnable)(ctx, 'external');
        }
        if (config.options.experimental && config.options.experimental.inline) {
            logger.error('   > ðŸ‘€ Enabling inline');
            ctx = (0, features_1.featureEnable)(ctx, 'inline');
        }
    }
    // Precompile
    try {
        ctx = (0, precompile_1.precompile)(ctx, project, stdlib, config.path);
    }
    catch (e) {
        logger.error('Tact compilation failed');
        logger.error((0, errorToString_1.errorToString)(e));
        return false;
    }
    // Compile contracts
    let ok = true;
    let built = {};
    for (let contract of (0, resolveDescriptors_1.getContracts)(ctx)) {
        let pathAbi = project.resolve(config.output, config.name + '_' + contract + ".abi");
        let pathCodeBoc = project.resolve(config.output, config.name + '_' + contract + ".code.boc");
        let pathCodeFif = project.resolve(config.output, config.name + '_' + contract + ".code.fif");
        let pathCodeFifDec = project.resolve(config.output, config.name + '_' + contract + ".code.rev.fif");
        let codeFc;
        let codeEntrypoint;
        // Compiling contract to func
        logger.log('   > ' + contract + ': tact compiler');
        let abi;
        try {
            let res = await (0, compile_1.compile)(ctx, contract, config.name + '_' + contract);
            for (let files of res.output.files) {
                let ffc = project.resolve(config.output, files.name);
                project.writeFile(ffc, files.code);
            }
            project.writeFile(pathAbi, res.output.abi);
            abi = res.output.abi;
            codeFc = res.output.files.map((v) => ({ path: posixNormalize(project.resolve(config.output, v.name)), content: v.code }));
            codeEntrypoint = res.output.entrypoint;
        }
        catch (e) {
            logger.error('Tact compilation failed');
            logger.error((0, errorToString_1.errorToString)(e));
            ok = false;
            continue;
        }
        // Compiling contract to TVM
        logger.log('   > ' + contract + ': func compiler');
        let codeBoc;
        try {
            let stdlibPath = stdlib.resolve('stdlib.fc');
            let stdlibCode = stdlib.readFile(stdlibPath).toString();
            let stdlibExPath = stdlib.resolve('stdlib_ex.fc');
            let stdlibExCode = stdlib.readFile(stdlibExPath).toString();
            let c = await (0, funcCompile_1.funcCompile)({
                entries: [
                    stdlibPath,
                    stdlibExPath,
                    posixNormalize(project.resolve(config.output, codeEntrypoint))
                ],
                sources: [{
                        path: stdlibPath,
                        content: stdlibCode
                    }, {
                        path: stdlibExPath,
                        content: stdlibExCode,
                    },
                    ...codeFc
                ],
                logger
            });
            if (!c.ok) {
                logger.error(c.log);
                ok = false;
                continue;
            }
            project.writeFile(pathCodeFif, c.fift);
            project.writeFile(pathCodeBoc, c.output);
            codeBoc = c.output;
        }
        catch (e) {
            logger.error('FunC compiler crashed');
            logger.error((0, errorToString_1.errorToString)(e));
            ok = false;
            continue;
        }
        // Fift decompiler for generated code debug
        logger.log('   > ' + contract + ': fift decompiler');
        let codeFiftDecompiled;
        try {
            codeFiftDecompiled = (0, opcode_1.decompileAll)({ src: codeBoc });
            project.writeFile(pathCodeFifDec, codeFiftDecompiled);
        }
        catch (e) {
            logger.error('Fift decompiler crashed');
            logger.error((0, errorToString_1.errorToString)(e));
            ok = false;
            continue;
        }
        // Add to built map
        built[contract] = {
            // codeFunc,
            codeBoc,
            // codeFift,
            // codeFiftDecompiled,
            abi
        };
    }
    if (!ok) {
        logger.log('ðŸ’¥ Compilation failed. Skipping packaging');
        return false;
    }
    // Package
    logger.log('   > Packaging');
    let contracts = (0, resolveDescriptors_1.getContracts)(ctx);
    let packages = [];
    for (let contract of contracts) {
        logger.log('   > ' + contract);
        let artifacts = built[contract];
        if (!artifacts) {
            logger.error('   > ' + contract + ': no artifacts found');
            return false;
        }
        // System cell
        const depends = ton_core_1.Dictionary.empty(ton_core_1.Dictionary.Keys.Uint(16), ton_core_1.Dictionary.Values.Cell());
        const ct = (0, resolveDescriptors_1.getType)(ctx, contract);
        depends.set(ct.uid, ton_core_1.Cell.fromBoc(built[ct.name].codeBoc)[0]); // Mine
        for (let c of ct.dependsOn) {
            let cd = built[c.name];
            if (!cd) {
                logger.error('   > ' + cd + ': no artifacts found');
                return false;
            }
            depends.set(c.uid, ton_core_1.Cell.fromBoc(cd.codeBoc)[0]);
        }
        const systemCell = (0, ton_core_1.beginCell)().storeDict(depends).endCell();
        // Collect sources
        let sources = {};
        let rawAst = (0, store_1.getRawAST)(ctx);
        for (let source of [...rawAst.funcSources, ...rawAst.sources]) {
            if (source.path.startsWith(project.root) && !source.path.startsWith(stdlib.root)) {
                sources[source.path.slice(project.root.length)] = Buffer.from(source.code).toString('base64');
            }
        }
        // Package
        let pkg = {
            name: contract,
            abi: artifacts.abi,
            code: artifacts.codeBoc.toString('base64'),
            init: {
                kind: 'direct',
                args: (0, resolveDescriptors_1.getType)(ctx, contract).init.args.map((v) => ({ name: v.name, type: (0, resolveABITypeRef_1.createABITypeRefFromTypeRef)(v.type, v.ref) })),
                prefix: {
                    bits: 1,
                    value: 0,
                },
                deployment: {
                    kind: 'system-cell',
                    system: systemCell.toBoc().toString('base64')
                },
            },
            sources,
            compiler: {
                name: 'tact',
                version: (0, version_1.getCompilerVersion)(),
                parameters: cfg
            }
        };
        let pkgData = (0, packageCode_1.packageCode)(pkg);
        let pathPkg = project.resolve(config.output, config.name + '_' + contract + ".pkg");
        project.writeFile(pathPkg, pkgData);
        packages.push(pkg);
    }
    // Bindings
    logger.log('   > Bindings');
    for (let pkg of packages) {
        logger.log('   > ' + pkg.name);
        if (pkg.init.deployment.kind !== 'system-cell') {
            logger.error('   > ' + pkg.name + ': unsupported deployment kind ' + pkg.init.deployment.kind);
            return false;
        }
        try {
            let bindingsServer = (0, writeTypescript_1.writeTypescript)(JSON.parse(pkg.abi), {
                code: pkg.code,
                prefix: pkg.init.prefix,
                system: pkg.init.deployment.system,
                args: pkg.init.args
            });
            project.writeFile(project.resolve(config.output, config.name + '_' + pkg.name + ".ts"), bindingsServer);
        }
        catch (e) {
            logger.error('Bindings compiler crashed');
            logger.error((0, errorToString_1.errorToString)(e));
            return false;
        }
    }
    // Reports
    logger.log('   > Reports');
    for (let pkg of packages) {
        logger.log('   > ' + pkg.name);
        try {
            let report = (0, writeReport_1.writeReport)(ctx, pkg);
            let pathBindings = project.resolve(config.output, config.name + '_' + pkg.name + ".md");
            project.writeFile(pathBindings, report);
        }
        catch (e) {
            logger.error('Report generation crashed');
            logger.error((0, errorToString_1.errorToString)(e));
            return false;
        }
    }
    return true;
}
exports.build = build;
