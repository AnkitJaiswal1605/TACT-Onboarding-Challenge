"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeMainContract = exports.writeInit = exports.writeStorageOps = void 0;
const errors_1 = require("../../abi/errors");
const features_1 = require("../../config/features");
const id_1 = require("./id");
const ops_1 = require("./ops");
const resolveFuncPrimitive_1 = require("./resolveFuncPrimitive");
const resolveFuncType_1 = require("./resolveFuncType");
const resolveFuncTypeUnpack_1 = require("./resolveFuncTypeUnpack");
const writeExpression_1 = require("./writeExpression");
const writeFunction_1 = require("./writeFunction");
const writeInterfaces_1 = require("./writeInterfaces");
const writeRouter_1 = require("./writeRouter");
function writeStorageOps(type, origin, ctx) {
    // Load function
    ctx.fun(ops_1.ops.contractLoad(type.name, ctx), () => {
        ctx.signature(`${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} ${ops_1.ops.contractLoad(type.name, ctx)}()`);
        ctx.flag('impure');
        // ctx.flag('inline');
        ctx.context('type:' + type.name + '$init');
        ctx.body(() => {
            // Load data slice
            ctx.append(`slice $sc = get_data().begin_parse();`);
            // Load context
            ctx.append(`__tact_context_sys = $sc~load_ref();`);
            ctx.append(`int $loaded = $sc~load_int(1);`);
            // Load data
            ctx.append(`if ($loaded) {`);
            ctx.inIndent(() => {
                if (type.fields.length > 0) {
                    ctx.append(`return $sc~${ops_1.ops.reader(type.name, ctx)}();`);
                }
                else {
                    ctx.append(`return null();`);
                }
            });
            ctx.append(`} else {`);
            ctx.inIndent(() => {
                // Allow only workchain deployments
                if (!(0, features_1.enabledMaterchain)(ctx.ctx)) {
                    ctx.write(`;; Allow only workchain deployments`);
                    ctx.write(`throw_unless(${errors_1.contractErrors.masterchainNotEnabled.id}, my_address().preload_uint(11) == 1024);`);
                }
                // Load arguments
                if (type.init.args.length > 0) {
                    ctx.append(`(${type.init.args.map((v) => (0, resolveFuncType_1.resolveFuncType)(v.type, ctx) + ' ' + v.name).join(', ')}) = $sc~${ops_1.ops.reader((0, id_1.initId)(type.name), ctx)}();`);
                    ctx.append(`$sc.end_parse();`);
                }
                // Execute init function
                ctx.append(`return ${ops_1.ops.contractInit(type.name, ctx)}(${[...type.init.args.map((v) => v.name)].join(', ')});`);
            });
            ctx.append(`}`);
        });
    });
    // Store function
    ctx.fun(ops_1.ops.contractStore(type.name, ctx), () => {
        const sig = `() ${ops_1.ops.contractStore(type.name, ctx)}(${(0, resolveFuncType_1.resolveFuncType)(type, ctx)} v)`;
        ctx.signature(sig);
        ctx.flag('impure');
        ctx.flag('inline');
        ctx.context('type:' + type.name + '$init');
        ctx.body(() => {
            ctx.append(`builder b = begin_cell();`);
            // Persist system cell
            ctx.append(`b = b.store_ref(__tact_context_sys);`);
            // Persist deployment flag
            ctx.append(`b = b.store_int(true, 1);`);
            // Build data
            if (type.fields.length > 0) {
                ctx.append(`b = ${ops_1.ops.writer(type.name, ctx)}(b, v);`);
            }
            // Persist data
            ctx.append(`set_data(b.end_cell());`);
        });
    });
}
exports.writeStorageOps = writeStorageOps;
function writeInit(t, init, ctx) {
    ctx.fun(ops_1.ops.contractInit(t.name, ctx), () => {
        const args = init.args.map((v) => (0, resolveFuncType_1.resolveFuncType)(v.type, ctx) + ' ' + (0, id_1.id)(v.name));
        const sig = `${(0, resolveFuncType_1.resolveFuncType)(t, ctx)} ${ops_1.ops.contractInit(t.name, ctx)}(${args.join(', ')})`;
        ctx.signature(sig);
        ctx.flag('impure');
        ctx.body(() => {
            // Unpack args
            for (let a of init.args) {
                if (!(0, resolveFuncPrimitive_1.resolveFuncPrimitive)(a.type, ctx)) {
                    ctx.append(`var (${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(a.type, (0, id_1.id)(a.name), ctx)}) = ${(0, id_1.id)(a.name)};`);
                }
            }
            // Generate self initial tensor
            let initValues = [];
            for (let i = 0; i < t.fields.length; i++) {
                let init = 'null()';
                if (t.fields[i].default !== undefined) {
                    init = (0, writeExpression_1.writeValue)(t.fields[i].default, ctx);
                }
                initValues.push(init);
            }
            if (initValues.length > 0) { // Special case for empty contracts
                ctx.append(`var (${(0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, (0, id_1.id)('self'), ctx)}) = (${initValues.join(', ')});`);
            }
            else {
                ctx.append(`tuple ${(0, id_1.id)('self')} = null();`);
            }
            // Generate statements
            let returns = (0, resolveFuncTypeUnpack_1.resolveFuncTypeUnpack)(t, (0, id_1.id)('self'), ctx);
            for (let s of init.ast.statements) {
                (0, writeFunction_1.writeStatement)(s, returns, null, ctx);
            }
            // Return result
            if (init.ast.statements.length === 0 || init.ast.statements[init.ast.statements.length - 1].kind !== 'statement_return') {
                ctx.append(`return ${returns};`);
            }
        });
    });
    ctx.fun(ops_1.ops.contractInitChild(t.name, ctx), () => {
        const args = [`cell sys'`, ...init.args.map((v) => (0, resolveFuncType_1.resolveFuncType)(v.type, ctx) + ' ' + (0, id_1.id)(v.name))];
        const sig = `(cell, cell) ${ops_1.ops.contractInitChild(t.name, ctx)}(${args.join(', ')})`;
        ctx.signature(sig);
        if ((0, features_1.enabledInline)(ctx.ctx)) {
            ctx.flag('inline');
        }
        ctx.context('type:' + t.name + '$init');
        ctx.body(() => {
            ctx.write(`
                slice sc' = sys'.begin_parse();
                cell source = sc'~load_dict();
                cell contracts = new_dict();

                ;; Contract Code: ${t.name}
                cell mine = ${ctx.used(`__tact_dict_get_code`)}(source, ${t.uid});
                contracts = ${ctx.used(`__tact_dict_set_code`)}(contracts, ${t.uid}, mine);
            `);
            // Copy contracts code
            for (let c of t.dependsOn) {
                ctx.append();
                ctx.write(`
                ;; Contract Code: ${c.name}
                cell code_${c.uid} = __tact_dict_get_code(source, ${c.uid});
                contracts = ${ctx.used(`__tact_dict_set_code`)}(contracts, ${c.uid}, code_${c.uid});
            `);
            }
            // Build cell
            ctx.append();
            ctx.append(`;; Build cell`);
            ctx.append(`builder b = begin_cell();`);
            ctx.append(`b = b.store_ref(begin_cell().store_dict(contracts).end_cell());`);
            ctx.append(`b = b.store_int(false, 1);`);
            let args = t.init.args.length > 0 ? ['b', '(' + t.init.args.map((a) => (0, id_1.id)(a.name)).join(', ') + ')'].join(', ') : 'b, null()';
            ctx.append(`b = ${ops_1.ops.writer((0, id_1.initId)(t.name), ctx)}(${args});`);
            ctx.append(`return (mine, b.end_cell());`);
        });
    });
}
exports.writeInit = writeInit;
function writeMainContract(type, abiLink, ctx) {
    // Main field
    ctx.main(() => {
        // Comments
        ctx.append(`;;`);
        ctx.append(`;; Receivers of a Contract ${type.name}`);
        ctx.append(`;;`);
        ctx.append(``);
        // Write receivers
        for (let r of Object.values(type.receivers)) {
            (0, writeRouter_1.writeReceiver)(type, r, ctx);
        }
        // Comments
        ctx.append(`;;`);
        ctx.append(`;; Get methods of a Contract ${type.name}`);
        ctx.append(`;;`);
        ctx.append(``);
        // Getters
        for (let f of type.functions.values()) {
            if (f.isGetter) {
                (0, writeFunction_1.writeGetter)(f, ctx);
            }
        }
        // Interfaces
        (0, writeInterfaces_1.writeInterfaces)(type, ctx);
        // ABI
        ctx.append(`_ get_abi_ipfs() method_id {`);
        ctx.inIndent(() => {
            ctx.append(`return "${abiLink}";`);
        });
        ctx.append(`}`);
        ctx.append();
        // Deployed
        ctx.append(`_ lazy_deployment_completed() method_id {`);
        ctx.inIndent(() => {
            ctx.append(`return get_data().begin_parse().load_int(1);`);
        });
        ctx.append(`}`);
        ctx.append();
        // Comments
        ctx.append(`;;`);
        ctx.append(`;; Routing of a Contract ${type.name}`);
        ctx.append(`;;`);
        ctx.append(``);
        // Render body
        const hasExternal = type.receivers.find((v) => v.selector.kind.startsWith('external-'));
        (0, writeRouter_1.writeRouter)(type, 'internal', ctx);
        if (hasExternal) {
            (0, writeRouter_1.writeRouter)(type, 'external', ctx);
        }
        // Render internal receiver
        ctx.append(`() recv_internal(int msg_value, cell in_msg_cell, slice in_msg) impure {`);
        ctx.inIndent(() => {
            // Load context
            ctx.append();
            ctx.append(`;; Context`);
            ctx.append(`var cs = in_msg_cell.begin_parse();`);
            ctx.append(`var msg_flags = cs~load_uint(4);`); // int_msg_info$0 ihr_disabled:Bool bounce:Bool bounced:Bool
            ctx.append(`var msg_bounced = -(msg_flags & 1);`);
            ctx.append(`slice msg_sender_addr = ${ctx.used('__tact_verify_address')}(cs~load_msg_addr());`);
            ctx.append(`__tact_context = (msg_bounced, msg_sender_addr, msg_value, cs);`);
            ctx.append(`__tact_context_sender = msg_sender_addr;`);
            ctx.append();
            // Load self
            ctx.append(`;; Load contract data`);
            ctx.append(`var self = ${ops_1.ops.contractLoad(type.name, ctx)}();`);
            ctx.append();
            // Process operation
            ctx.append(`;; Handle operation`);
            ctx.append(`int handled = self~${ops_1.ops.contractRouter(type.name, 'internal')}(msg_bounced, in_msg);`);
            ctx.append();
            // Throw if not handled
            ctx.append(`;; Throw if not handled`);
            ctx.append(`throw_unless(${errors_1.contractErrors.invalidMessage.id}, handled);`);
            ctx.append();
            // Persist state
            ctx.append(`;; Persist state`);
            ctx.append(`${ops_1.ops.contractStore(type.name, ctx)}(self);`);
        });
        ctx.append('}');
        ctx.append();
        // Render external receiver
        if (hasExternal) {
            ctx.append(`() recv_external(slice in_msg) impure {`);
            ctx.inIndent(() => {
                // Load self
                ctx.append(`;; Load contract data`);
                ctx.append(`var self = ${ops_1.ops.contractLoad(type.name, ctx)}();`);
                ctx.append();
                // Process operation
                ctx.append(`;; Handle operation`);
                ctx.append(`int handled = self~${ops_1.ops.contractRouter(type.name, 'external')}(in_msg);`);
                ctx.append();
                // Throw if not handled
                ctx.append(`;; Throw if not handled`);
                ctx.append(`throw_unless(handled, ${errors_1.contractErrors.invalidMessage.id});`);
                ctx.append();
                // Persist state
                ctx.append(`;; Persist state`);
                ctx.append(`${ops_1.ops.contractStore(type.name, ctx)}(self);`);
            });
            ctx.append('}');
            ctx.append();
        }
    });
}
exports.writeMainContract = writeMainContract;
