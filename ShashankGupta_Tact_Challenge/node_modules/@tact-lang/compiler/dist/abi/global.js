"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GlobalFunctions = void 0;
const ton_core_1 = require("ton-core");
const features_1 = require("../config/features");
const writeConstant_1 = require("../generator/writers/writeConstant");
const writeExpression_1 = require("../generator/writers/writeExpression");
const ast_1 = require("../grammar/ast");
const resolveConstantValue_1 = require("../types/resolveConstantValue");
const resolveErrors_1 = require("../types/resolveErrors");
const ton_crypto_1 = require("ton-crypto");
exports.GlobalFunctions = {
    ton: {
        name: 'ton',
        resolve: (ctx, args, ref) => {
            if (args.length !== 1) {
                (0, ast_1.throwError)('ton() expects single string argument', ref);
            }
            if (args[0].kind !== 'ref') {
                (0, ast_1.throwError)('ton() expects single string argument', ref);
            }
            if (args[0].name !== 'String') {
                (0, ast_1.throwError)('ton() expects single string argument', ref);
            }
            return { kind: 'ref', name: 'Int', optional: false };
        },
        generate: (ctx, args, resolved, ref) => {
            if (resolved.length !== 1) {
                (0, ast_1.throwError)('ton() expects single string argument', ref);
            }
            let str = (0, resolveConstantValue_1.resolveConstantValue)({ kind: 'ref', name: 'String', optional: false }, resolved[0], ctx.ctx);
            return (0, ton_core_1.toNano)(str).toString(10);
        }
    },
    pow: {
        name: 'pow',
        resolve: (ctx, args, ref) => {
            if (args.length !== 2) {
                (0, ast_1.throwError)('pow() expects two integer arguments', ref);
            }
            if (args[0].kind !== 'ref') {
                (0, ast_1.throwError)('pow() expects two integer arguments', ref);
            }
            if (args[0].name !== 'Int') {
                (0, ast_1.throwError)('pow() expects two integer arguments', ref);
            }
            if (args[1].kind !== 'ref') {
                (0, ast_1.throwError)('pow() expects two integer arguments', ref);
            }
            if (args[1].name !== 'Int') {
                (0, ast_1.throwError)('pow() expects two integer arguments', ref);
            }
            return { kind: 'ref', name: 'Int', optional: false };
        },
        generate: (ctx, args, resolved, ref) => {
            if (resolved.length !== 2) {
                (0, ast_1.throwError)('pow() expects two integer arguments', ref);
            }
            let a = (0, resolveConstantValue_1.resolveConstantValue)({ kind: 'ref', name: 'Int', optional: false }, resolved[0], ctx.ctx);
            let b = (0, resolveConstantValue_1.resolveConstantValue)({ kind: 'ref', name: 'Int', optional: false }, resolved[1], ctx.ctx);
            return (a ** b).toString(10);
        }
    },
    require: {
        name: 'require',
        resolve: (ctx, args, ref) => {
            if (args.length !== 2) {
                (0, ast_1.throwError)('require() expects two arguments', ref);
            }
            if (args[0].kind !== 'ref') {
                (0, ast_1.throwError)('require() expects first Bool argument', ref);
            }
            if (args[0].name !== 'Bool') {
                (0, ast_1.throwError)('require() expects first Bool argument', ref);
            }
            if (args[1].kind !== 'ref') {
                (0, ast_1.throwError)('require() expects second string argument', ref);
            }
            if (args[1].name !== 'String') {
                (0, ast_1.throwError)('require() expects second string argument', ref);
            }
            return { kind: 'void' };
        },
        generate: (ctx, args, resolved, ref) => {
            if (resolved.length !== 2) {
                (0, ast_1.throwError)('require() expects two arguments', ref);
            }
            let str = (0, resolveConstantValue_1.resolveConstantValue)({ kind: 'ref', name: 'String', optional: false }, resolved[1], ctx.ctx);
            return `throw_unless(${(0, resolveErrors_1.getErrorId)(str, ctx.ctx)}, ${(0, writeExpression_1.writeExpression)(resolved[0], ctx)})`;
        }
    },
    address: {
        name: 'address',
        resolve: (ctx, args, ref) => {
            if (args.length !== 1) {
                (0, ast_1.throwError)('address() expects one argument', ref);
            }
            if (args[0].kind !== 'ref') {
                (0, ast_1.throwError)('address() expects string argument', ref);
            }
            if (args[0].name !== 'String') {
                (0, ast_1.throwError)('address() expects string argument', ref);
            }
            return { kind: 'ref', name: 'Address', optional: false };
        },
        generate: (ctx, args, resolved, ref) => {
            if (resolved.length !== 1) {
                (0, ast_1.throwError)('address() expects one argument', ref);
            }
            let str = (0, resolveConstantValue_1.resolveConstantValue)({ kind: 'ref', name: 'String', optional: false }, resolved[0], ctx.ctx);
            let address = ton_core_1.Address.parse(str);
            if (address.workChain !== 0 && address.workChain !== -1) {
                (0, ast_1.throwError)(`Address ${str} invalid address`, ref);
            }
            if (!(0, features_1.enabledMaterchain)(ctx.ctx)) {
                if (address.workChain !== 0) {
                    (0, ast_1.throwError)(`Address ${str} from masterchain are not enabled for this contract`, ref);
                }
            }
            // Generate address
            let res = (0, writeConstant_1.writeAddress)(address, ctx);
            ctx.used(res);
            return res + '()';
        }
    },
    cell: {
        name: 'cell',
        resolve: (ctx, args, ref) => {
            if (args.length !== 1) {
                (0, ast_1.throwError)('cell() expects one argument', ref);
            }
            if (args[0].kind !== 'ref') {
                (0, ast_1.throwError)('cell() expects string argument', ref);
            }
            if (args[0].name !== 'String') {
                (0, ast_1.throwError)('cell() expects string argument', ref);
            }
            return { kind: 'ref', name: 'Cell', optional: false };
        },
        generate: (ctx, args, resolved, ref) => {
            if (resolved.length !== 1) {
                (0, ast_1.throwError)('cell() expects one argument', ref);
            }
            // Load cell data
            let str = (0, resolveConstantValue_1.resolveConstantValue)({ kind: 'ref', name: 'String', optional: false }, resolved[0], ctx.ctx);
            let c;
            try {
                c = ton_core_1.Cell.fromBase64(str);
            }
            catch (e) {
                (0, ast_1.throwError)(`Invalid cell ${str}`, ref);
            }
            // Generate address
            let res = (0, writeConstant_1.writeCell)(c, ctx);
            ctx.used(res);
            return `${res}()`;
        }
    },
    dump: {
        name: 'dump',
        resolve: (ctx, args, ref) => {
            if (args.length !== 1) {
                (0, ast_1.throwError)('dump expects 1 argument', ref);
            }
            return { kind: 'void' };
        },
        generate: (ctx, args, resolved, ref) => {
            if (!(0, features_1.enabledDebug)(ctx.ctx)) {
                return `${ctx.used('__tact_nop')}()`;
            }
            let arg = args[0];
            if (arg.kind === 'map') {
                let exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                return `${ctx.used(`__tact_debug`)}(${exp})`;
            }
            else if (arg.kind === 'null') {
                return `${ctx.used(`__tact_debug_str`)}("null")`;
            }
            else if (arg.kind === 'void') {
                return `${ctx.used(`__tact_debug_str`)}("void")`;
            }
            else if (arg.kind === 'ref') {
                if (arg.name === 'Int' || arg.name === 'Builder' || arg.name === 'Slice' || arg.name === 'Cell' || arg.name === 'StringBuilder') {
                    let exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                    return `${ctx.used(`__tact_debug_str`)}(${ctx.used(`__tact_int_to_string`)}(${exp}))`;
                }
                else if (arg.name === 'Bool') {
                    let exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                    return `${ctx.used(`__tact_debug_bool`)}(${exp})`;
                }
                else if (arg.name === 'String') {
                    let exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                    return `${ctx.used(`__tact_debug_str`)}(${exp})`;
                }
                (0, ast_1.throwError)('dump() not supported for type: ' + arg.name, ref);
            }
            else {
                (0, ast_1.throwError)('dump() not supported for argument', ref);
            }
        }
    },
    emptyMap: {
        name: 'emptyMap',
        resolve: (ctx, args, ref) => {
            if (args.length !== 0) {
                (0, ast_1.throwError)('emptyMap expects no arguments', ref);
            }
            return { kind: 'null' };
        },
        generate: (ctx, args, resolved, ref) => {
            return 'null()';
        }
    },
    sha256: {
        name: 'sha256',
        resolve: (ctx, args, ref) => {
            if (args.length !== 1) {
                (0, ast_1.throwError)('sha256 expects 1 argument', ref);
            }
            if (args[0].kind !== 'ref') {
                (0, ast_1.throwError)('sha256 expects string argument', ref);
            }
            if (args[0].name !== 'String' && args[0].name !== 'Slice') {
                (0, ast_1.throwError)('sha256 expects string or slice argument', ref);
            }
            return { kind: 'ref', name: 'Int', optional: false };
        },
        generate: (ctx, args, resolved, ref) => {
            if (args.length !== 1) {
                (0, ast_1.throwError)('sha256 expects 1 argument', ref);
            }
            if (args[0].kind !== 'ref') {
                (0, ast_1.throwError)('sha256 expects string argument', ref);
            }
            // String case
            if (args[0].name === 'String') {
                try {
                    let str = (0, resolveConstantValue_1.resolveConstantValue)({ kind: 'ref', name: 'String', optional: false }, resolved[0], ctx.ctx);
                    if (Buffer.from(str).length > 128) {
                        (0, ast_1.throwError)('sha256 expects string argument with byte length <= 128', ref);
                    }
                    return BigInt('0x' + (0, ton_crypto_1.sha256_sync)(str).toString('hex')).toString(10);
                }
                catch (e) {
                    // Not a constant
                }
                let exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                return `string_hash(${exp})`;
            }
            // Slice case
            if (args[0].name === 'Slice') {
                let exp = (0, writeExpression_1.writeExpression)(resolved[0], ctx);
                return `string_hash(${exp})`;
            }
            (0, ast_1.throwError)('sha256 expects string or slice argument', ref);
        }
    }
};
