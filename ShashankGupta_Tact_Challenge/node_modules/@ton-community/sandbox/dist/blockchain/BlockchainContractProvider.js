"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BlockchainContractProvider = void 0;
const ton_core_1 = require("ton-core");
function bigintToBuffer(x, n = 32) {
    const b = Buffer.alloc(n);
    for (let i = 0; i < n; i++) {
        b[n - i - 1] = Number((x >> BigInt(i * 8)) & 0xffn);
    }
    return b;
}
function convertState(state) {
    if (state === undefined)
        return {
            type: 'uninit'
        };
    switch (state.type) {
        case 'uninit':
            return {
                type: 'uninit'
            };
        case 'active':
            return {
                type: 'active',
                code: state.state.code?.toBoc(),
                data: state.state.data?.toBoc(),
            };
        case 'frozen':
            return {
                type: 'frozen',
                stateHash: bigintToBuffer(state.stateHash)
            };
    }
}
class BlockchainContractProvider {
    constructor(blockchain, address, init) {
        this.blockchain = blockchain;
        this.address = address;
        this.init = init;
    }
    async getState() {
        const contract = await this.blockchain.getContract(this.address);
        return {
            balance: contract.balance,
            last: {
                lt: contract.lastTransactionLt,
                hash: bigintToBuffer(contract.lastTransactionHash),
            },
            state: convertState(contract.accountState),
        };
    }
    async get(name, args) {
        const result = await this.blockchain.runGetMethod(this.address, name, args);
        return {
            stack: result.stackReader,
            gasUsed: result.gasUsed,
            logs: result.vmLogs,
        };
    }
    async external(message) {
        const init = ((await this.getState()).state.type !== 'active' && this.init) ? this.init : undefined;
        await this.blockchain.pushMessage({
            info: {
                type: 'external-in',
                dest: this.address,
                importFee: 0n,
            },
            init,
            body: message,
        });
    }
    async internal(via, args) {
        const init = ((await this.getState()).state.type !== 'active' && this.init) ? this.init : undefined;
        const bounce = (args.bounce !== null && args.bounce !== undefined) ? args.bounce : true;
        const value = typeof args.value === 'string' ? (0, ton_core_1.toNano)(args.value) : args.value;
        const body = typeof args.body === 'string' ? (0, ton_core_1.comment)(args.body) : args.body;
        await via.send({
            to: this.address,
            value,
            bounce,
            sendMode: args.sendMode,
            init,
            body,
        });
    }
    async tickTock(which) {
        await this.blockchain.pushTickTock(this.address, which);
    }
}
exports.BlockchainContractProvider = BlockchainContractProvider;
