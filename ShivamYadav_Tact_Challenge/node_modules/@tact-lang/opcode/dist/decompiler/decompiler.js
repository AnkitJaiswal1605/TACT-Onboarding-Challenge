"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.decompile = void 0;
const ton_core_1 = require("ton-core");
const loadOpcode_1 = require("../codepage/loadOpcode");
const subcell_1 = require("../utils/subcell");
function decompile(args) {
    // Result collection
    let result = [];
    // Load slice
    let source;
    if (Buffer.isBuffer(args.src)) {
        source = ton_core_1.Cell.fromBoc(args.src)[0];
    }
    else if (args.src instanceof ton_core_1.Cell) {
        source = args.src;
    }
    else {
        throw new Error('Invalid source');
    }
    // Hash
    let hash = source.hash().toString('hex');
    // Prepare offset
    let bitsDelta = 0;
    let refsDelta = 0;
    if (args.offset) {
        bitsDelta = args.offset.bits;
        refsDelta = args.offset.refs;
    }
    // Prepare offset
    let bitsLimit = args.limit ? (args.limit.bits) : source.bits.length - bitsDelta;
    let refsLimit = args.limit ? (args.limit.refs) : source.refs.length - refsDelta;
    let slice = (0, subcell_1.subslice)({
        cell: source,
        offsetBits: bitsDelta,
        offsetRefs: refsDelta,
        bits: bitsLimit,
        refs: refsLimit
    });
    while (slice.remainingBits > 0) {
        // Load opcode
        const opcodeOffset = slice.offsetBits;
        const opcode = (0, loadOpcode_1.loadOpcode)(slice, source);
        const opcodeLength = slice.offsetBits - opcodeOffset;
        // Failed case
        if (!opcode.ok) {
            if (args.allowUnknown) {
                let fullCell = (0, ton_core_1.beginCell)();
                for (let bit of Array.from(opcode.read).map(a => a == '0' ? false : true)) {
                    fullCell.storeBit(bit);
                }
                fullCell.storeSlice(slice);
                result.push({
                    op: {
                        code: 'unknown',
                        data: fullCell.endCell()
                    },
                    hash,
                    offset: opcodeOffset,
                    length: opcodeLength
                });
                break;
            }
            else {
                throw Error('Unknown opcode: b' + opcode.read);
            }
        }
        // Push opcode to result
        result.push({
            op: opcode.read,
            hash,
            offset: opcodeOffset,
            length: opcodeLength
        });
        // Implicit jump
        if (slice.remainingBits === 0 && slice.remainingRefs > 0) {
            source = slice.loadRef();
            hash = source.hash().toString('hex');
            slice = source.beginParse();
        }
    }
    return result;
}
exports.decompile = decompile;
