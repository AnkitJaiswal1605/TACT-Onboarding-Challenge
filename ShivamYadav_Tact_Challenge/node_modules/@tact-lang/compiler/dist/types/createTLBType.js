"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTLBType = void 0;
const ton_core_1 = require("ton-core");
const cs = __importStar(require("change-case"));
const ton_crypto_1 = require("ton-crypto");
function createTypeFormat(type, format) {
    if (type === 'int') {
        if (typeof format === 'number') {
            return `int${format}`;
        }
        else if (format !== null) {
            throw Error('Unsupported int format ' + format);
        }
        return `int`;
    }
    else if (type === 'uint') {
        if (typeof format === 'number') {
            return `uint${format}`;
        }
        else if (format === 'coins') {
            return `coins`;
        }
        else if (format !== null) {
            throw Error('Unsupported uint format ' + format);
        }
        return `uint`;
    }
    else if (type === 'bool') {
        if (format !== null) {
            throw Error('Unsupported bool format ' + format);
        }
        return 'bool';
    }
    else if (type === 'address') {
        if (format !== null) {
            throw Error('Unsupported address format ' + format);
        }
        return 'address';
    }
    else if (type === 'cell') {
        if (format === 'remainder') {
            return 'remainder<cell>';
        }
        else if (format === 'ref') {
            return '^cell';
        }
        if (format !== null) {
            throw Error('Unsupported cell format ' + format);
        }
        return '^cell';
    }
    else if (type === 'slice') {
        if (format === 'remainder') {
            return 'remainder<slice>';
        }
        else if (format === 'ref') {
            return '^slice';
        }
        else if (format !== null) {
            throw Error('Unsupported cell format ' + format);
        }
        return '^slice';
    }
    else if (type === 'fixed-bytes') {
        if (typeof format === 'number') {
            return `fixed_bytes${format}`;
        }
        else if (format !== null) {
            throw Error('Unsupported fixed-bytes format ' + format);
        }
        throw Error('Missing fixed-bytes format');
    }
    // Struct types
    if (format === 'ref') {
        return `^${type}`;
    }
    else if (format !== null) {
        throw Error('Unsupported struct format ' + format);
    }
    return type;
}
function createTLBField(src) {
    if (src.type.kind === 'simple') {
        let base = createTypeFormat(src.type.type, src.type.format ? src.type.format : null);
        if (src.type.optional) {
            base = 'Maybe ' + base;
        }
        return src.name + ':' + base;
    }
    if (src.type.kind === 'dict') {
        if (src.type.format !== null && src.type.format !== undefined) {
            throw Error('Unsupported map format ' + src.type.format);
        }
        let key = createTypeFormat(src.type.key, src.type.keyFormat ? src.type.keyFormat : null);
        let value = createTypeFormat(src.type.value, src.type.valueFormat ? src.type.valueFormat : null);
        return src.name + ':dict<' + key + ', ' + value + '>';
    }
    throw Error('Unsupported ABI field');
}
function createTLBType(name, args, kind, knownHeader) {
    let fields = args.map(createTLBField).join(' ');
    if (kind === 'struct') {
        return { tlb: '_ ' + fields + ' = ' + name, header: null };
    }
    else {
        let base = cs.snakeCase(name) + ' ' + fields + ' = ' + name;
        let op = knownHeader !== null ? knownHeader : (0, ton_core_1.beginCell)().storeBuffer((0, ton_crypto_1.sha256_sync)(base)).endCell().beginParse().loadUint(32);
        let opText = (0, ton_core_1.beginCell)().storeUint(op, 32).endCell().beginParse().loadBuffer(4).toString('hex');
        let res = cs.snakeCase(name) + '#' + opText + ' ' + fields + ' = ' + name;
        return { tlb: res, header: op };
    }
}
exports.createTLBType = createTLBType;
