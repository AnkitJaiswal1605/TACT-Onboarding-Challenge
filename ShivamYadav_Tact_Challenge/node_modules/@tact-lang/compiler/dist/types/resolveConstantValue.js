"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveConstantValue = void 0;
const ton_core_1 = require("ton-core");
const features_1 = require("../config/features");
const ast_1 = require("../grammar/ast");
const types_1 = require("./types");
const ton_crypto_1 = require("ton-crypto");
function reduceInt(ast) {
    if (ast.kind === 'number') {
        return ast.value;
    }
    else if (ast.kind === 'op_binary') {
        let l = reduceInt(ast.left);
        let r = reduceInt(ast.right);
        if (ast.op === '+') {
            return l + r;
        }
        else if (ast.op === '-') {
            return l - r;
        }
        else if (ast.op === '*') {
            return l * r;
        }
        else if (ast.op === '/') {
            return l / r;
        }
        else if (ast.op === '%') {
            return l % r;
        }
        else if (ast.op === '<<') {
            return l << r;
        }
        else if (ast.op === '>>') {
            return l >> r;
        }
        else if (ast.op === '&') {
            return l & r;
        }
        else if (ast.op === '|') {
            return l | r;
        }
    }
    else if (ast.kind === 'op_unary') {
        if (ast.op === '-') {
            return -reduceInt(ast.right);
        }
        else if (ast.op === '+') {
            return reduceInt(ast.right);
        }
    }
    else if (ast.kind === 'op_static_call') {
        if (ast.name === 'ton') {
            if (ast.args.length === 1) {
                return BigInt((0, ton_core_1.toNano)(reduceString(ast.args[0])).toString(10));
            }
        }
        if (ast.name === 'pow') {
            if (ast.args.length === 2) {
                return reduceInt(ast.args[0]) ** reduceInt(ast.args[1]);
            }
        }
        if (ast.name === 'sha256') {
            if (ast.args.length === 1 && ast.args[0].kind === 'string') {
                let str = reduceString(ast.args[0]);
                if (Buffer.from(str).length <= 128) {
                    return BigInt('0x' + (0, ton_crypto_1.sha256_sync)(str).toString('hex'));
                }
            }
        }
    }
    (0, ast_1.throwError)('Cannot reduce expression to a constant integer', ast.ref);
}
function reduceBool(ast) {
    if (ast.kind === 'boolean') {
        return ast.value;
    }
    if (ast.kind === 'op_unary') {
        if (ast.op === '!') {
            return !reduceBool(ast.right);
        }
    }
    if (ast.kind === 'op_binary') {
        if (ast.op === '&&') {
            return reduceBool(ast.left) && reduceBool(ast.right);
        }
        else if (ast.op === '||') {
            return reduceBool(ast.left) || reduceBool(ast.right);
        }
        // TODO: More cases
    }
    (0, ast_1.throwError)('Cannot reduce expression to a constant boolean', ast.ref);
}
function reduceString(ast) {
    if (ast.kind === 'string') {
        return ast.value;
    }
    (0, ast_1.throwError)('Cannot reduce expression to a constant string', ast.ref);
}
function reduceAddress(ast, ctx) {
    if (ast.kind === 'op_static_call') {
        if (ast.name === 'address') {
            if (ast.args.length === 1) {
                const str = reduceString(ast.args[0]);
                let address = ton_core_1.Address.parse(str);
                if (address.workChain !== 0 && address.workChain !== -1) {
                    (0, ast_1.throwError)(`Address ${str} invalid address`, ast.ref);
                }
                if (!(0, features_1.enabledMaterchain)(ctx)) {
                    if (address.workChain !== 0) {
                        (0, ast_1.throwError)(`Address ${str} from masterchain are not enabled for this contract`, ast.ref);
                    }
                }
                return address;
            }
        }
    }
    (0, ast_1.throwError)('Cannot reduce expression to a constant Address', ast.ref);
}
function reduceCell(ast, ctx) {
    if (ast.kind === 'op_static_call') {
        if (ast.name === 'cell') {
            if (ast.args.length === 1) {
                const str = reduceString(ast.args[0]);
                let c;
                try {
                    c = ton_core_1.Cell.fromBase64(str);
                }
                catch (e) {
                    (0, ast_1.throwError)(`Invalid cell ${str}`, ast.ref);
                }
                return c;
            }
        }
    }
    (0, ast_1.throwError)('Cannot reduce expression to a constant Address', ast.ref);
}
function resolveConstantValue(type, ast, ctx) {
    if (ast === null) {
        return undefined;
    }
    if (type.kind !== 'ref') {
        (0, ast_1.throwError)(`Expected constant value, got ${(0, types_1.printTypeRef)(type)}`, ast.ref);
    }
    // Handle optional
    if (type.optional) {
        if (ast.kind === 'null') {
            return null;
        }
    }
    // Handle int
    if (type.name === 'Int') {
        return reduceInt(ast);
    }
    // Handle bool
    if (type.name === 'Bool') {
        return reduceBool(ast);
    }
    // Handle string
    if (type.name === 'String') {
        return reduceString(ast);
    }
    // Handle Address
    if (type.name === 'Address') {
        return reduceAddress(ast, ctx);
    }
    // Handle Cell
    if (type.name === 'Cell') {
        return reduceCell(ast, ctx);
    }
    (0, ast_1.throwError)(`Expected constant value, got ${(0, types_1.printTypeRef)(type)}`, ast.ref);
}
exports.resolveConstantValue = resolveConstantValue;
