"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bn_js_1 = require("bn.js");
const ton_crypto_1 = require("ton-crypto");
const CommonMessageInfo_1 = require("../messages/CommonMessageInfo");
const EmptyMessage_1 = require("../messages/EmptyMessage");
const InternalMessage_1 = require("../messages/InternalMessage");
const awaitBalance_1 = require("../tests/awaitBalance");
const awaitCondition_1 = require("../tests/awaitCondition");
const createTestClient_1 = require("../tests/createTestClient");
const openTestTreasure_1 = require("../tests/openTestTreasure");
const convert_1 = require("../utils/convert");
const time_1 = require("../utils/time");
// import { delay } from "../utils/time";
// import { WalletV1R1Source } from "./sources/WalletV1R1Source";
const WalletV1R2Source_1 = require("./sources/WalletV1R2Source");
const WalletV1R3Source_1 = require("./sources/WalletV1R3Source");
const WalletV2R1Source_1 = require("./sources/WalletV2R1Source");
const WalletV2R2Source_1 = require("./sources/WalletV2R2Source");
const WalletV3R1Source_1 = require("./sources/WalletV3R1Source");
const WalletV3R2Source_1 = require("./sources/WalletV3R2Source");
const WalletContract_1 = require("./WalletContract");
async function testSource(secretKey, source) {
    const client = (0, createTestClient_1.createTestClient)();
    const treasure = await (0, openTestTreasure_1.openTestTreasure)(client);
    const contract = WalletContract_1.WalletContract.create(client, source);
    console.log('testing contract: ' + source.type + ' at ' + contract.address.toFriendly());
    let treasureSeqno = await (0, time_1.backoff)(() => treasure.wallet.getSeqNo(), false);
    await (0, time_1.backoff)(() => treasure.wallet.transfer({ to: contract.address, seqno: treasureSeqno, value: (0, convert_1.toNano)(0.1), secretKey: treasure.secretKey, bounce: false }), false);
    console.log('awaiting transfer');
    await (0, awaitBalance_1.awaitBalance)(client, contract.address, new bn_js_1.BN(0));
    // Update seqno
    console.log('sending transaction');
    let seqno = await (0, time_1.backoff)(() => contract.getSeqNo(), false);
    expect(seqno).toBe(0);
    const transfer = contract.createTransfer({
        seqno,
        sendMode: 3,
        secretKey,
        order: new InternalMessage_1.InternalMessage({
            to: treasure.wallet.address,
            value: (0, convert_1.toNano)(0.05),
            bounce: true,
            body: new CommonMessageInfo_1.CommonMessageInfo({ body: new EmptyMessage_1.EmptyMessage() })
        })
    });
    await (0, time_1.backoff)(() => client.sendExternalMessage(contract, transfer), false);
    // Check seqno
    console.log('awaiting seqno');
    await (0, awaitCondition_1.awaitCondition)(30000, async () => (await (0, time_1.backoff)(() => contract.getSeqNo(), false)) > 0);
}
describe('WalletContract', () => {
    // it('should work for v1r1 contract', async () => {
    //     let mnemonic = await mnemonicNew(24);
    //     let key = await mnemonicToWalletKey(mnemonic);
    //     await testSource(key.secretKey, WalletV1R1Source.create({ publicKey: key.publicKey, workchain: 0 }));
    // }, 60000);
    it('should work for v1r2 contract', async () => {
        let mnemonic = await (0, ton_crypto_1.mnemonicNew)(24);
        let key = await (0, ton_crypto_1.mnemonicToWalletKey)(mnemonic);
        await testSource(key.secretKey, WalletV1R2Source_1.WalletV1R2Source.create({ publicKey: key.publicKey, workchain: 0 }));
        await testSource(key.secretKey, WalletV1R2Source_1.WalletV1R2Source.create({ publicKey: key.publicKey, workchain: -1 }));
    }, 120000);
    it('should work for v1r3 contract', async () => {
        let mnemonic = await (0, ton_crypto_1.mnemonicNew)(24);
        let key = await (0, ton_crypto_1.mnemonicToWalletKey)(mnemonic);
        await testSource(key.secretKey, WalletV1R3Source_1.WalletV1R3Source.create({ publicKey: key.publicKey, workchain: 0 }));
        await testSource(key.secretKey, WalletV1R3Source_1.WalletV1R3Source.create({ publicKey: key.publicKey, workchain: -1 }));
    }, 120000);
    it('should work for v2r1 contract', async () => {
        let mnemonic = await (0, ton_crypto_1.mnemonicNew)(24);
        let key = await (0, ton_crypto_1.mnemonicToWalletKey)(mnemonic);
        await testSource(key.secretKey, WalletV2R1Source_1.WalletV2R1Source.create({ publicKey: key.publicKey, workchain: 0 }));
        await testSource(key.secretKey, WalletV2R1Source_1.WalletV2R1Source.create({ publicKey: key.publicKey, workchain: -1 }));
    }, 120000);
    it('should work for v2r2 contract', async () => {
        let mnemonic = await (0, ton_crypto_1.mnemonicNew)(24);
        let key = await (0, ton_crypto_1.mnemonicToWalletKey)(mnemonic);
        await testSource(key.secretKey, WalletV2R2Source_1.WalletV2R2Source.create({ publicKey: key.publicKey, workchain: 0 }));
        await testSource(key.secretKey, WalletV2R2Source_1.WalletV2R2Source.create({ publicKey: key.publicKey, workchain: -1 }));
    }, 120000);
    it('should work for v3r1 contract', async () => {
        let mnemonic = await (0, ton_crypto_1.mnemonicNew)(24);
        let key = await (0, ton_crypto_1.mnemonicToWalletKey)(mnemonic);
        await testSource(key.secretKey, WalletV3R1Source_1.WalletV3R1Source.create({ publicKey: key.publicKey, workchain: 0 }));
        await testSource(key.secretKey, WalletV3R1Source_1.WalletV3R1Source.create({ publicKey: key.publicKey, workchain: -1 }));
    }, 120000);
    it('should work for v3r2 contract', async () => {
        let mnemonic = await (0, ton_crypto_1.mnemonicNew)(24);
        let key = await (0, ton_crypto_1.mnemonicToWalletKey)(mnemonic);
        await testSource(key.secretKey, WalletV3R2Source_1.WalletV3R2Source.create({ publicKey: key.publicKey, workchain: 0 }));
        await testSource(key.secretKey, WalletV3R2Source_1.WalletV3R2Source.create({ publicKey: key.publicKey, workchain: -1 }));
    }, 120000);
});
