"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTransaction = exports.parseTransactionDescription = exports.parseBouncePhase = exports.parseActionPhase = exports.parseComputePhase = exports.parseCreditPhase = exports.parseStoragePhase = exports.parseStorageUsedShort = exports.parseAccountChange = exports.parseHashUpdate = exports.parseMessage = exports.parseStateInit = exports.parseCommonMsgInfo = exports.parseCurrencyCollection = exports.parseAccountStatus = void 0;
const __1 = require("..");
function parseAccountStatus(slice) {
    const status = slice.readUintNumber(2);
    if (status === 0x00) {
        return 'uninitialized';
    }
    if (status === 0x01) {
        return 'frozen';
    }
    if (status === 0x02) {
        return 'active';
    }
    if (status === 0x03) {
        return 'non-existing';
    }
    throw Error('Unreachable');
}
exports.parseAccountStatus = parseAccountStatus;
function parseCurrencyCollection(slice) {
    const coins = slice.readCoins();
    if (slice.readBit()) {
        throw Error('Currency collctions are not supported yet');
    }
    return { coins };
}
exports.parseCurrencyCollection = parseCurrencyCollection;
function parseCommonMsgInfo(slice) {
    if (!slice.readBit()) {
        // Internal
        let ihrDisabled = slice.readBit();
        let bounce = slice.readBit();
        let bounced = slice.readBit();
        let src = slice.readAddress();
        let dest = slice.readAddress();
        let value = parseCurrencyCollection(slice);
        let ihrFee = slice.readCoins();
        let fwdFee = slice.readCoins();
        let createdLt = slice.readUint(64);
        let createdAt = slice.readUintNumber(32);
        return {
            type: 'internal',
            ihrDisabled,
            bounce,
            bounced,
            src,
            dest,
            value,
            ihrFee,
            fwdFee,
            createdLt,
            createdAt
        };
    }
    else if (slice.readBit()) {
        // Outgoing external
        let src = slice.readAddress();
        let dest = slice.readAddress();
        let createdLt = slice.readUint(64);
        let createdAt = slice.readUintNumber(32);
        return {
            type: 'external-out',
            src,
            dest,
            createdLt,
            createdAt
        };
    }
    else {
        // Incoming external
        let src = slice.readAddress();
        let dest = slice.readAddress();
        let importFee = slice.readCoins();
        return {
            type: 'external-in',
            src,
            dest,
            importFee
        };
    }
}
exports.parseCommonMsgInfo = parseCommonMsgInfo;
function parseStateInit(slice) {
    if (slice.readBit()) {
        throw Error('Unsupported');
    }
    if (slice.readBit()) {
        throw Error('Unsupported');
    }
    const hasCode = slice.readBit();
    const code = hasCode ? slice.readCell() : null;
    const hasData = slice.readBit();
    const data = hasData ? slice.readCell() : null;
    if (slice.readBit()) {
        throw Error('Unsupported');
    }
    return { data, code };
}
exports.parseStateInit = parseStateInit;
function parseMessage(slice) {
    const info = parseCommonMsgInfo(slice);
    const hasInit = slice.readBit();
    let init = null;
    if (hasInit) {
        if (!slice.readBit()) {
            init = parseStateInit(slice);
        }
        else {
            init = parseStateInit(slice.readRef());
        }
    }
    const body = slice.readBit() ? slice.readRef().toCell() : slice.toCell();
    return {
        info,
        init,
        body
    };
}
exports.parseMessage = parseMessage;
function parseHashUpdate(slice) {
    if (slice.readUintNumber(8) !== 0x72) {
        throw Error('Invalid transaction');
    }
    const oldHash = slice.readBuffer(32);
    const newHash = slice.readBuffer(32);
    return { oldHash, newHash };
}
exports.parseHashUpdate = parseHashUpdate;
function parseAccountChange(slice) {
    if (!slice.readBit()) {
        return 'unchanged';
    }
    if (slice.readBit()) {
        return 'frozen';
    }
    else {
        return 'deleted';
    }
}
exports.parseAccountChange = parseAccountChange;
function parseStorageUsedShort(slice) {
    return {
        cells: slice.readVarUIntNumber(3),
        bits: slice.readVarUIntNumber(3)
    };
}
exports.parseStorageUsedShort = parseStorageUsedShort;
function parseStoragePhase(slice) {
    const storageFeesCollected = slice.readCoins();
    let storageFeesDue = null;
    if (slice.readBit()) {
        storageFeesDue = slice.readCoins();
    }
    const statusChange = parseAccountChange(slice);
    return {
        storageFeesCollected,
        storageFeesDue,
        statusChange
    };
}
exports.parseStoragePhase = parseStoragePhase;
function parseCreditPhase(slice) {
    let dueFeesColelcted = slice.readBit() ? slice.readCoins() : null;
    const credit = parseCurrencyCollection(slice);
    return {
        dueFeesColelcted,
        credit
    };
}
exports.parseCreditPhase = parseCreditPhase;
function parseComputePhase(slice) {
    if (!slice.readBit()) {
        const skipReason = slice.readUintNumber(2);
        if (skipReason === 0x00) {
            return {
                type: 'skipped',
                reason: 'no-state'
            };
        }
        if (skipReason === 0x01) {
            return {
                type: 'skipped',
                reason: 'bad-state'
            };
        }
        if (skipReason === 0x02) {
            return {
                type: 'skipped',
                reason: 'no-gas'
            };
        }
    }
    const success = slice.readBit();
    const messageStateUsed = slice.readBit();
    const accountActivated = slice.readBit();
    let gasFees = slice.readCoins();
    const vmState = slice.readRef();
    let gasUsed = vmState.readVarUInt(3);
    let gasLimit = vmState.readVarUInt(3);
    let gasCredit = vmState.readBit() ? vmState.readVarUInt(2) : null;
    let mode = vmState.readUintNumber(8);
    let exitCode = vmState.readUintNumber(32);
    let exitArg = vmState.readBit() ? vmState.readUintNumber(32) : null; // TODO: change to int
    let vmSteps = vmState.readUintNumber(32);
    let vmInitStateHash = vmState.readBuffer(32);
    let vmFinalStateHash = vmState.readBuffer(32);
    return {
        type: 'computed',
        success,
        messageStateUsed,
        accountActivated,
        gasFees,
        gasUsed,
        gasLimit,
        gasCredit,
        mode,
        exitCode,
        exitArg,
        vmSteps,
        vmInitStateHash,
        vmFinalStateHash
    };
}
exports.parseComputePhase = parseComputePhase;
function parseActionPhase(slice) {
    const success = slice.readBit();
    const valid = slice.readBit();
    const noFunds = slice.readBit();
    const statusChange = parseAccountChange(slice);
    const totalFwdFees = slice.readBit() ? slice.readCoins() : null;
    const totalActionFees = slice.readBit() ? slice.readCoins() : null;
    const resultCode = slice.readUintNumber(32); // TODO: Change to int32
    const resultArg = slice.readBit() ? slice.readUintNumber(32) : null; // TODO: Change to int32
    const totalActions = slice.readUintNumber(16);
    const specialActions = slice.readUintNumber(16);
    const skippedActions = slice.readUintNumber(16);
    const messagesCreated = slice.readUintNumber(16);
    const actionListHash = slice.readBuffer(32);
    const totalMessageSizes = parseStorageUsedShort(slice);
    return {
        success,
        valid,
        noFunds,
        statusChange,
        totalFwdFees,
        totalActionFees,
        resultCode,
        resultArg,
        totalActions,
        specialActions,
        skippedActions,
        messagesCreated,
        actionListHash,
        totalMessageSizes
    };
}
exports.parseActionPhase = parseActionPhase;
function parseBouncePhase(slice) {
    // Is OK
    if (slice.readBit()) {
        const msgSize = parseStorageUsedShort(slice);
        const msgFees = slice.readCoins();
        const fwdFees = slice.readCoins();
        return {
            type: 'ok',
            msgSize,
            msgFees,
            fwdFees
        };
    }
    // No funds
    if (slice.readBit()) {
        const msgSize = parseStorageUsedShort(slice);
        const fwdFees = slice.readCoins();
        return {
            type: 'no-funds',
            msgSize,
            fwdFees
        };
    }
    return {
        type: 'negative-funds'
    };
}
exports.parseBouncePhase = parseBouncePhase;
function parseTransactionDescription(slice) {
    const type = slice.readUintNumber(4);
    if (type === 0x00) {
        const creditFirst = slice.readBit();
        let storagePhase = null;
        let creditPhase = null;
        if (slice.readBit()) {
            storagePhase = parseStoragePhase(slice);
        }
        if (slice.readBit()) {
            creditPhase = parseCreditPhase(slice);
        }
        let computePhase = parseComputePhase(slice);
        let actionPhase = null;
        if (slice.readBit()) {
            actionPhase = parseActionPhase(slice.readRef());
        }
        let aborted = slice.readBit();
        let bouncePhase = null;
        if (slice.readBit()) {
            bouncePhase = parseBouncePhase(slice);
        }
        const destroyed = slice.readBit();
        return {
            type: 'generic',
            creditFirst,
            storagePhase,
            creditPhase,
            computePhase,
            actionPhase,
            bouncePhase,
            aborted,
            destroyed
        };
    }
    if (type === 0x01) {
        let storagePhase = parseStoragePhase(slice);
        return {
            type: 'storage',
            storagePhase
        };
    }
    if (type === 0x2 || type === 0x03) {
        const isTock = type === 0x03;
        let storagePhase = parseStoragePhase(slice);
        let computePhase = parseComputePhase(slice);
        let actionPhase = null;
        if (slice.readBit()) {
            actionPhase = parseActionPhase(slice.readRef());
        }
        const aborted = slice.readBit();
        const destroyed = slice.readBit();
        return {
            type: 'tick-tock',
            isTock,
            storagePhase,
            computePhase,
            actionPhase,
            aborted,
            destroyed
        };
    }
    throw Error('Unsupported transaction type');
}
exports.parseTransactionDescription = parseTransactionDescription;
function parseTransaction(workchain, slice) {
    if (slice.readUintNumber(4) !== 0x07) {
        throw Error('Invalid transaction');
    }
    // Read address
    const addressHash = slice.readBuffer(32);
    const address = new __1.Address(workchain, addressHash);
    // Read lt
    const lt = slice.readUint(64);
    // Read prevTrans
    const prevTransHash = slice.readBuffer(32);
    const prevTransLt = slice.readUint(64);
    // Read time
    const time = slice.readUintNumber(32);
    // Output messages
    const outMessagesCount = slice.readUintNumber(15);
    // Status
    const oldStatus = parseAccountStatus(slice);
    const newStatus = parseAccountStatus(slice);
    // Messages ref
    const messages = slice.readRef();
    let hasInMessage = messages.readBit();
    let hasOutMessages = messages.readBit();
    let inMessage = null;
    if (hasInMessage) {
        inMessage = parseMessage(messages.readRef());
    }
    let outMessages = [];
    if (hasOutMessages) {
        let dict = messages.readDict(15, (slice) => parseMessage(slice.readRef()));
        for (let msg of Array.from(dict.values())) {
            outMessages.push(msg);
        }
    }
    // Currency collections
    let fees = parseCurrencyCollection(slice);
    // Hash update
    let update = parseHashUpdate(slice.readRef());
    // Description
    let description = parseTransactionDescription(slice.readRef());
    return {
        address,
        lt,
        time,
        outMessagesCount,
        oldStatus,
        newStatus,
        fees,
        update,
        description,
        inMessage,
        outMessages,
        prevTransaction: {
            hash: prevTransHash,
            lt: prevTransLt
        }
    };
}
exports.parseTransaction = parseTransaction;
