"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TonClient_api;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonClient = void 0;
const ton_crypto_1 = require("ton-crypto");
const Address_1 = require("../address/Address");
const Cell_1 = require("../boc/Cell");
const HttpApi_1 = require("./api/HttpApi");
const ExternalMessage_1 = require("../messages/ExternalMessage");
const CommonMessageInfo_1 = require("../messages/CommonMessageInfo");
const StateInit_1 = require("../messages/StateInit");
const Wallet_1 = require("./Wallet");
const bn_js_1 = require("bn.js");
const __1 = require("..");
const ConfigContract_1 = require("../contracts/ConfigContract");
const TonCache_1 = require("./TonCache");
function convertMessage(t) {
    return {
        source: t.source !== '' ? Address_1.Address.parseFriendly(t.source).address : null,
        destination: t.destination !== '' ? Address_1.Address.parseFriendly(t.destination).address : null,
        forwardFee: new bn_js_1.BN(t.fwd_fee),
        ihrFee: new bn_js_1.BN(t.ihr_fee),
        value: new bn_js_1.BN(t.value),
        createdLt: t.created_lt,
        body: (t.msg_data['@type'] === 'msg.dataRaw'
            ? { type: 'data', data: Buffer.from(t.msg_data.body, 'base64') }
            : (t.msg_data['@type'] === 'msg.dataText'
                ? { type: 'text', text: Buffer.from(t.msg_data.text, 'base64').toString('utf-8') }
                : null))
    };
}
function convertTransaction(r) {
    return {
        id: { lt: r.transaction_id.lt, hash: r.transaction_id.hash },
        time: r.utime,
        data: r.data,
        storageFee: new bn_js_1.BN(r.storage_fee),
        otherFee: new bn_js_1.BN(r.other_fee),
        fee: new bn_js_1.BN(r.fee),
        inMessage: r.in_msg ? convertMessage(r.in_msg) : null,
        outMessages: r.out_msgs.map(convertMessage)
    };
}
class TonClient {
    constructor(parameters) {
        _TonClient_api.set(this, void 0);
        this.services = {
            configs: new ConfigContract_1.ConfigContract(this)
        };
        this.parameters = {
            endpoint: parameters.endpoint,
            cache: parameters.cache ? parameters.cache : new TonCache_1.InMemoryCache()
        };
        __classPrivateFieldSet(this, _TonClient_api, new HttpApi_1.HttpApi(this.parameters.endpoint, this.parameters.cache, {
            timeout: parameters.timeout,
            apiKey: parameters.apiKey,
            adapter: parameters.httpAdapter
        }), "f");
    }
    /**
     * Get Address Balance
     * @param address address for balance check
     * @returns balance
     */
    async getBalance(address) {
        return (await this.getContractState(address)).balance;
    }
    /**
     * Invoke get method
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
     */
    async callGetMethod(address, name, params = []) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").callGetMethod(address, name, params);
        if (res.exit_code !== 0) {
            throw Error('Unable to execute get method. Got exit_code: ' + res.exit_code);
        }
        return { gas_used: res.gas_used, stack: res.stack };
    }
    /**
     * Invoke get method that returns error code instead of throwing error
     * @param address contract address
     * @param name name of method
     * @param params optional parameters
     * @returns stack and gas_used field
    */
    async callGetMethodWithError(address, name, params = []) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").callGetMethod(address, name, params);
        return { gas_used: res.gas_used, stack: res.stack, exit_code: res.exit_code };
    }
    /**
     * Get transactions
     * @param address address
     */
    async getTransactions(address, opts) {
        // Fetch transactions
        let tx = await __classPrivateFieldGet(this, _TonClient_api, "f").getTransactions(address, opts);
        let res = [];
        for (let r of tx) {
            res.push(convertTransaction(r));
        }
        return res;
    }
    /**
     * Get transaction by it's id
     * @param address address
     * @param lt logical time
     * @param hash transaction hash
     * @returns transaction or null if not exist
     */
    async getTransaction(address, lt, hash) {
        let res = await __classPrivateFieldGet(this, _TonClient_api, "f").getTransaction(address, lt, hash);
        if (res) {
            return convertTransaction(res);
        }
        else {
            return null;
        }
    }
    /**
     * Fetch latest masterchain info
     * @returns masterchain info
     */
    async getMasterchainInfo() {
        let r = await __classPrivateFieldGet(this, _TonClient_api, "f").getMasterchainInfo();
        return {
            workchain: r.init.workchain,
            shard: r.last.shard,
            initSeqno: r.init.seqno,
            latestSeqno: r.last.seqno
        };
    }
    /**
     * Fetch latest workchain shards
     * @param seqno masterchain seqno
     */
    async getWorkchainShards(seqno) {
        let r = await __classPrivateFieldGet(this, _TonClient_api, "f").getShards(seqno);
        return r.map((m) => ({
            workchain: m.workchain,
            shard: m.shard,
            seqno: m.seqno
        }));
    }
    /**
     * Fetch transactions inf shards
     * @param workchain
     * @param seqno
     * @param shard
     */
    async getShardTransactions(workchain, seqno, shard) {
        let tx = await __classPrivateFieldGet(this, _TonClient_api, "f").getBlockTransactions(workchain, seqno, shard);
        if (tx.incomplete) {
            throw Error('Unsupported');
        }
        return tx.transactions.map((v) => ({
            account: Address_1.Address.parseRaw(v.account),
            lt: v.lt,
            hash: v.hash
        }));
    }
    /**
     * Send message to a network
     * @param src source message
     */
    async sendMessage(src) {
        const cell = new Cell_1.Cell();
        src.writeTo(cell);
        const boc = await cell.toBoc({ idx: false });
        await __classPrivateFieldGet(this, _TonClient_api, "f").sendBoc(boc);
    }
    /**
     * Send file to a network
     * @param src source file
     */
    async sendFile(src) {
        await __classPrivateFieldGet(this, _TonClient_api, "f").sendBoc(src);
    }
    /**
     * Estimate fees for external message
     * @param address target address
     * @returns
     */
    async estimateExternalMessageFee(address, args) {
        return await __classPrivateFieldGet(this, _TonClient_api, "f").estimateFee(address, { body: args.body, initCode: args.initCode, initData: args.initData, ignoreSignature: args.ignoreSignature });
    }
    /**
     * Send external message to contract
     * @param contract contract to send message
     * @param src message body
     */
    async sendExternalMessage(contract, src) {
        if (await this.isContractDeployed(contract.address)) {
            const message = new ExternalMessage_1.ExternalMessage({
                to: contract.address,
                body: new CommonMessageInfo_1.CommonMessageInfo({
                    body: new __1.CellMessage(src)
                })
            });
            await this.sendMessage(message);
        }
        else {
            const message = new ExternalMessage_1.ExternalMessage({
                to: contract.address,
                body: new CommonMessageInfo_1.CommonMessageInfo({
                    stateInit: new StateInit_1.StateInit({ code: contract.source.initialCode, data: contract.source.initialData }),
                    body: new __1.CellMessage(src)
                })
            });
            await this.sendMessage(message);
        }
    }
    /**
     * Check if contract is deployed
     * @param address addres to check
     * @returns true if contract is in active state
     */
    async isContractDeployed(address) {
        return (await this.getContractState(address)).state === 'active';
    }
    /**
     * Resolves contract state
     * @param address contract address
     */
    async getContractState(address) {
        let info = await __classPrivateFieldGet(this, _TonClient_api, "f").getAddressInformation(address);
        let balance = new bn_js_1.BN(info.balance);
        let state = info.state;
        return {
            balance,
            state,
            code: info.code !== '' ? Buffer.from(info.code, 'base64') : null,
            data: info.data !== '' ? Buffer.from(info.data, 'base64') : null,
            lastTransaction: info.last_transaction_id.lt !== '0' ? {
                lt: info.last_transaction_id.lt,
                hash: info.last_transaction_id.hash,
            } : null,
            blockId: {
                workchain: info.block_id.workchain,
                shard: info.block_id.shard,
                seqno: info.block_id.seqno
            },
            timestampt: info.sync_utime
        };
    }
    /**
     * Open Wallet from address
     * @param source wallet address
     * @returns wallet with specified address
     */
    openWalletFromAddress(args) {
        return Wallet_1.Wallet.open(this, args.source);
    }
    /**
     * Open Wallet from secret key. Searches for best wallet contract.
     * @param workchain wallet workchain
     * @param secretKey wallet secret key
     * @returns best matched wallet
     */
    findWalletFromSecretKey(args) {
        return Wallet_1.Wallet.findBestBySecretKey(this, args.workchain, args.secretKey);
    }
    /**
     * Open wallet with default contract
     * @param args workchain and secret key
     * @returns wallet
     */
    openWalletDefaultFromSecretKey(args) {
        return Wallet_1.Wallet.openDefault(this, args.workchain, args.secretKey);
    }
    /**
     * Open wallet with default contract
     * @param args workchain and secret key
     * @returns wallet
     */
    openWalletFromSecretKey(args) {
        return Wallet_1.Wallet.openByType(this, args.workchain, args.secretKey, args.type);
    }
    /**
     * Opens wallet from custom contract
     * @param src source
     * @returns wallet
     */
    openWalletFromCustomContract(src) {
        return Wallet_1.Wallet.openFromSource(this, src);
    }
    /**
     * Securely creates new wallet
     * @param password optional password
     */
    async createNewWallet(args) {
        let mnemonic = await (0, ton_crypto_1.mnemonicNew)(24, args.password);
        let key = await (0, ton_crypto_1.mnemonicToWalletKey)(mnemonic, args.password);
        let kind = args.type || 'org.ton.wallets.v3';
        let wallet = Wallet_1.Wallet.openByType(this, args.workchain, key.secretKey, kind);
        return {
            mnemonic,
            key,
            wallet
        };
    }
}
exports.TonClient = TonClient;
_TonClient_api = new WeakMap();
