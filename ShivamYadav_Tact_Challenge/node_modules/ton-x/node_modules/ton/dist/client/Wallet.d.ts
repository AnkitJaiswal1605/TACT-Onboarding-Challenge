/// <reference types="node" />
import BN from "bn.js";
import { Address, Cell, TonClient } from "..";
import { WalletSource } from "../contracts/sources/WalletSource";
import { Maybe } from "../types";
import { SendMode } from "./SendMode";
export declare type WalletContractType = 'org.ton.wallets.simple' | 'org.ton.wallets.simple.r2' | 'org.ton.wallets.simple.r3' | 'org.ton.wallets.v2' | 'org.ton.wallets.v2.r2' | 'org.ton.wallets.v3' | 'org.ton.wallets.v3.r2';
export declare function validateWalletType(src: string): WalletContractType | null;
export declare class Wallet {
    #private;
    static open(client: TonClient, address: Address): Wallet;
    static openDefault(client: TonClient, workchain: number, secretKey: Buffer): Wallet;
    static openByType(client: TonClient, workchain: number, secretKey: Buffer, type: WalletContractType): Wallet;
    static openFromSource(client: TonClient, source: WalletSource): Wallet;
    static findActiveBySecretKey(client: TonClient, workchain: number, secretKey: Buffer): Promise<{
        address: Address;
        type: WalletContractType;
        deployed: boolean;
        balance: BN;
    }[]>;
    static findBestBySecretKey(client: TonClient, workchain: number, secretKey: Buffer): Promise<Wallet>;
    readonly address: Address;
    get prepared(): boolean;
    private constructor();
    getSeqNo(): Promise<number>;
    prepare(workchain: number, publicKey: Buffer, type?: WalletContractType): void;
    prepareFromSource(source: WalletSource): void;
    /**
     * Transfers value to specified address
     */
    transfer(args: {
        seqno: number;
        to: Address;
        value: BN;
        secretKey: Buffer;
        bounce: boolean;
        sendMode?: Maybe<SendMode>;
        timeout?: Maybe<number>;
        payload?: Maybe<string | Buffer>;
    }): Promise<void>;
    /**
     * Signing transfer request. Could be done offline.
     * @param args sign
     * @returns
     */
    transferSign(args: {
        to: Address;
        bounce: boolean;
        seqno: number;
        value: BN;
        secretKey: Buffer;
        payload?: Maybe<string | Buffer>;
        timeout?: Maybe<number>;
        sendMode?: Maybe<SendMode>;
    }): Cell;
    /**
     * Commit prepared transfer
     * @param transfer signed transfer for commit
     */
    transferCommit(transfer: Cell): Promise<void>;
}
