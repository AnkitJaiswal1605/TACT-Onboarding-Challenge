"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.beginCell = exports.Builder = void 0;
const BitString_1 = require("./BitString");
const Cell_1 = require("./Cell");
class Builder {
    constructor() {
        this.bits = BitString_1.BitString.alloc(1023);
        this.refs = [];
        this.ended = false;
        this.storeRef = (src) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.refs.push(src);
            return this;
        };
        this.storeBit = (value) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.bits.writeBit(value);
            return this;
        };
        this.storeBitArray = (value) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.bits.writeBitArray(value);
            return this;
        };
        this.storeUint = (value, bitLength) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.bits.writeUint(value, bitLength);
            return this;
        };
        this.storeInt = (value, bitLength) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.bits.writeInt(value, bitLength);
            return this;
        };
        this.storeUint8 = (value) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.bits.writeUint8(value);
            return this;
        };
        this.storeBuffer = (buffer) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.bits.writeBuffer(buffer);
            return this;
        };
        this.storeCoins = (amount) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.bits.writeCoins(amount);
            return this;
        };
        this.storeAddress = (address) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.bits.writeAddress(address);
            return this;
        };
        this.storeBitString = (value) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            this.bits.writeBitString(value);
            return this;
        };
        this.storeDict = (src) => {
            if (this.ended) {
                throw Error('Already ended');
            }
            if (src) {
                this.bits.writeBit(true);
                this.refs.push(src);
            }
            else {
                this.bits.writeBit(false);
            }
            return this;
        };
        this.storeRefMaybe = (src) => {
            return this.storeDict(src);
        };
    }
    endCell() {
        if (this.ended) {
            throw Error('Already ended');
        }
        this.ended = true;
        let res = new Cell_1.Cell(false, this.bits);
        for (let r of this.refs) {
            res.refs.push(r);
        }
        return res;
    }
}
exports.Builder = Builder;
function beginCell() {
    return new Builder();
}
exports.beginCell = beginCell;
