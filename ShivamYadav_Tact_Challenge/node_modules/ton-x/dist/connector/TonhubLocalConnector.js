"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _TonhubLocalConnector_instances, _TonhubLocalConnector_provider, _TonhubLocalConnector_doRequest;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TonhubLocalConnector = void 0;
const t = __importStar(require("io-ts"));
const ton_1 = require("ton");
const extractPublicKeyAndAddress_1 = require("../contracts/extractPublicKeyAndAddress");
const configCodec = t.type({
    version: t.literal(1),
    platform: t.union([t.literal('ios'), t.literal('android')]),
    platformVersion: t.union([t.string, t.number]),
    network: t.union([t.literal('testnet'), t.literal('mainnet')]),
    address: t.string,
    publicKey: t.string,
    walletConfig: t.string,
    walletType: t.string,
    signature: t.string,
    time: t.number,
    subkey: t.type({
        domain: t.string,
        publicKey: t.string,
        time: t.number,
        signature: t.string
    })
});
class TonhubLocalConnector {
    constructor(network) {
        _TonhubLocalConnector_instances.add(this);
        _TonhubLocalConnector_provider.set(this, void 0);
        if (typeof window === 'undefined') {
            throw Error('Not running in browser');
        }
        if (!(window['ton-x'])) {
            throw Error('Not running in dApp browser');
        }
        let tx = (window['ton-x']);
        if (tx.__IS_TON_X !== true) {
            throw Error('Not running in dApp browser');
        }
        let cfg = tx.config;
        if (!configCodec.is(cfg)) {
            throw Error('Not running in dApp browser');
        }
        if (cfg.network !== network) {
            throw Error('Invalid network');
        }
        this.network = network;
        this.config = {
            version: cfg.version,
            network: cfg.network,
            address: cfg.address,
            publicKey: cfg.publicKey,
            walletConfig: cfg.walletConfig,
            walletType: cfg.walletType,
            signature: cfg.signature,
            time: cfg.time,
            subkey: {
                domain: cfg.subkey.domain,
                publicKey: cfg.subkey.publicKey,
                time: cfg.subkey.time,
                signature: cfg.subkey.signature
            }
        };
        __classPrivateFieldSet(this, _TonhubLocalConnector_provider, tx.call, "f");
        Object.freeze(this.config.subkey);
        Object.freeze(this.config);
        Object.freeze(this);
    }
    static verifyWalletConfig(config) {
        // Check address
        const address = ton_1.Address.parseFriendly(config.address).address;
        // Extract public key and address
        let extracted = (0, extractPublicKeyAndAddress_1.extractPublicKeyAndAddress)(config);
        if (!extracted) {
            return false;
        }
        // Check address
        if (!extracted.address.equals(address)) {
            return false;
        }
        // Verify subkey
        const toSignSub = (0, ton_1.beginCell)()
            .storeCoins(1)
            .storeBuffer(Buffer.from(config.subkey.publicKey, 'base64'))
            .storeUint(config.subkey.time, 32)
            .storeAddress(extracted.address)
            .storeRef((0, ton_1.beginCell)()
            .storeBuffer(Buffer.from(config.subkey.domain))
            .endCell())
            .endCell();
        if (!(0, ton_1.safeSignVerify)(toSignSub, Buffer.from(config.subkey.signature, 'base64'), extracted.publicKey)) {
            return false;
        }
        // Verify wallet
        const toSign = (0, ton_1.beginCell)()
            .storeCoins(1)
            .storeAddress(extracted.address)
            .storeUint(config.time, 32)
            .storeRef((0, ton_1.beginCell)()
            .storeBuffer(Buffer.from(config.subkey.domain))
            .endCell())
            .endCell();
        // Check signature
        return (0, ton_1.safeSignVerify)(toSign, Buffer.from(config.signature, 'base64'), Buffer.from(config.subkey.publicKey, 'base64'));
    }
    static isAvailable() {
        if (typeof window === 'undefined') {
            return false;
        }
        if (!(window['ton-x'])) {
            return false;
        }
        let tx = (window['ton-x']);
        if (tx.__IS_TON_X !== true) {
            return false;
        }
        if (!configCodec.is(tx.config)) {
            return false;
        }
        return true;
    }
    async requestTransaction(request) {
        let res = await __classPrivateFieldGet(this, _TonhubLocalConnector_instances, "m", _TonhubLocalConnector_doRequest).call(this, 'tx', {
            network: this.network,
            to: request.to,
            value: request.value,
            stateInit: request.stateInit ? request.stateInit : null,
            text: request.text ? request.text : null,
            payload: request.payload ? request.payload : null,
        });
        if (res.type === 'ok') {
            let d = res.data;
            if (d.state === 'rejected') {
                return { type: 'rejected' };
            }
            if (d.state === 'sent') {
                return { type: 'success', response: d.result };
            }
            throw Error('Unknown reponse');
        }
        throw Error(res.message);
    }
    async requestSign(request) {
        // Parse data
        let data = new ton_1.Cell();
        if (typeof request.payload === 'string') {
            data = ton_1.Cell.fromBoc(Buffer.from(request.payload, 'base64'))[0];
        }
        // Comment
        let comment = '';
        if (typeof request.text === 'string') {
            comment = request.text;
        }
        let commentCell = new ton_1.Cell();
        new ton_1.CommentMessage(comment).writeTo(commentCell);
        let res = await __classPrivateFieldGet(this, _TonhubLocalConnector_instances, "m", _TonhubLocalConnector_doRequest).call(this, 'sign', {
            network: this.network,
            textCell: commentCell.toBoc({ idx: false }).toString('base64'),
            payloadCell: data.toBoc({ idx: false }).toString('base64')
        });
        if (res.type === 'ok') {
            let d = res.data;
            if (d.state === 'rejected') {
                return { type: 'rejected' };
            }
            if (d.state === 'sent') {
                return { type: 'success', signature: d.result };
            }
            throw Error('Unknown reponse');
        }
        throw Error(res.message);
    }
}
exports.TonhubLocalConnector = TonhubLocalConnector;
_TonhubLocalConnector_provider = new WeakMap(), _TonhubLocalConnector_instances = new WeakSet(), _TonhubLocalConnector_doRequest = async function _TonhubLocalConnector_doRequest(name, args) {
    return await new Promise((resolve) => __classPrivateFieldGet(this, _TonhubLocalConnector_provider, "f").call(this, name, args, resolve));
};
